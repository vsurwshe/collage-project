<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
	"http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<title>[16] Freestore management &nbsp;Updated!&nbsp;, C++ FAQ Lite</title>
<meta name="FILENAME" content="freestore-mgmt.html">
<meta name="ABSTRACT" content="[16] Freestore management [Updated!], C++ FAQ Lite">
<meta name="OWNER"    content="cline@parashift.com">
<meta name="AUTHOR"   content="Marshall Cline, cline@parashift.com">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rev=made href="mailto:cline@parashift.com">
<style type='text/css'>
  <!--
  body       { font-family: arial; color: black; background: white }
  .CodeBlock { color: black; background-color: #dfdfdf; margin-left: 30px; margin-right: 30px; padding: 5pt }
  .FaqTitle  { color: black; background-color: gold }
  .Updated   { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #ffff00; border: solid #e0e000 1px; }
  .New       { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #00ff00; border: solid #00d000 1px; }
  ul         { margin-bottom: 1px; margin-top: 1px }
  ol         { margin-bottom: 1px; margin-top: 1px }
  li         { margin-bottom: 4px; margin-top: 4px }
  a          { color: blue }
  a:hover    { color: red }
  -->
</style>
</head>
<body>
<h1><a name="top"></a>[16] Freestore management <span class=Updated>&nbsp;Updated!&nbsp;</span><br>
<small><small>(Part of <a href="index.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>, <a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">Copyright&nbsp;&copy; 1991-2003</a>, <a href="http://www.parashift.com/" title="www.parashift.com/" target='_blank'>Marshall Cline</a>, <a href="mailto:cline@parashift.com" title="cline@parashift.com"><tt>cline@parashift.com</tt></a>)</small></small></h1>
<hr>
<h3>FAQs in section [16]:</h3>
<ul>
<li><a href="freestore-mgmt.html#faq-16.1" title="[16.1] Does delete p delete the pointer p, or the pointed-to-data *p?">[16.1] Does <nobr><tt>delete p</tt></nobr> delete the pointer <tt>p</tt>, or the pointed-to-data <nobr><tt>*p</tt></nobr>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.2" title="[16.2] Can I free() pointers allocated with new? Can I delete pointers allocated with malloc()?">[16.2] Can I <nobr><tt>free()</tt></nobr> pointers allocated with <tt>new</tt>? Can I <tt>delete</tt> pointers allocated with <nobr><tt>malloc()</tt></nobr>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.3" title="[16.3] Why should I use new instead of trustworthy old malloc()?">[16.3] Why should I use <tt>new</tt> instead of trustworthy old <nobr><tt>malloc()</tt></nobr>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.4" title="[16.4] Can I use realloc() on pointers allocated via new?">[16.4] Can I use <nobr><tt>realloc()</tt></nobr> on pointers allocated via <tt>new</tt>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.5" title="[16.5] Do I need to check for NULL after p = new Fred()?">[16.5] Do I need to check for <tt>NULL</tt> after <nobr><tt>p = new Fred()</tt></nobr>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.6" title="[16.6] How can I convince my (older) compiler to automatically check new to see if it returns NULL?">[16.6] How can I convince my (older) compiler to automatically check <tt>new</tt> to see if it returns <tt>NULL</tt>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.7" title="[16.7] Do I need to check for NULL before delete p?">[16.7] Do I need to check for <tt>NULL</tt> before <nobr><tt>delete p</tt></nobr>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.8" title="[16.8] What are the two steps that happen when I say delete p?">[16.8] What are the two steps that happen when I say <nobr><tt>delete p</tt></nobr>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.9" title="[16.9] In p = new Fred(), does the Fred memory &quot;leak&quot; if the Fred constructor throws an exception?">[16.9] In <nobr><tt>p = new Fred()</tt></nobr>, does the <tt>Fred</tt> memory &quot;leak&quot; if the <tt>Fred</tt> constructor throws an exception?</a></li>
<li><a href="freestore-mgmt.html#faq-16.10" title="[16.10] How do I allocate / unallocate an array of things?">[16.10] How do I allocate / unallocate an array of things?</a></li>
<li><a href="freestore-mgmt.html#faq-16.11" title="[16.11] What if I forget the [] when deleteing array allocated via new T[n]?">[16.11] What if I forget the <nobr><tt>[]</tt></nobr> when <tt>delete</tt>ing array allocated via <nobr><tt>new T[n]</tt></nobr>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.12" title="[16.12] Can I drop the [] when deleteing array of some built-in type (char, int, etc)?">[16.12] Can I drop the <nobr><tt>[]</tt></nobr> when <tt>delete</tt>ing array of some built-in type (<tt>char</tt>, <tt>int</tt>, etc)?</a></li>
<li><a href="freestore-mgmt.html#faq-16.13" title="[16.13] After p = new Fred[n], how does the compiler know there are n objects to be destructed during delete[] p?">[16.13] After <nobr><tt>p = new Fred[n]</tt></nobr>, how does the compiler know there are <tt>n</tt> objects to be destructed during <nobr><tt>delete[] p</tt></nobr>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.14" title="[16.14] Is it legal (and moral) for a member function to say delete this?">[16.14] Is it legal (and moral) for a member function to say <nobr><tt>delete this</tt></nobr>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.15" title="[16.15] How do I allocate multidimensional arrays using new?">[16.15] How do I allocate multidimensional arrays using <tt>new</tt>?</a></li>
<li><a href="freestore-mgmt.html#faq-16.16" title="[16.16] But the previous FAQ's code is SOOOO tricky and error prone! Isn't there a simpler way?">[16.16] But the previous FAQ's code is SOOOO tricky and error prone! Isn't there a simpler way?</a> <span class=Updated>&nbsp;Updated!&nbsp;</span></li>
<li><a href="freestore-mgmt.html#faq-16.17" title="[16.17] But the above Matrix class is specific to Fred! Isn't there a way to make it generic?">[16.17] But the above <tt>Matrix</tt> class is specific to <tt>Fred</tt>! Isn't there a way to make it generic?</a></li>
<li><a href="freestore-mgmt.html#faq-16.18" title="[16.18] What's another way to build a Matrix template?">[16.18] What's another way to build a <tt>Matrix</tt> template?</a> <span class=Updated>&nbsp;Updated!&nbsp;</span></li>
<li><a href="freestore-mgmt.html#faq-16.19" title="[16.19] Does C++ have arrays whose length can be specified at run-time?">[16.19] Does C++ have arrays whose length can be specified at run-time?</a></li>
<li><a href="freestore-mgmt.html#faq-16.20" title="[16.20] How can I force objects of my class to always be created via new rather than as locals or global/static objects?">[16.20] How can I force objects of my class to always be created via <tt>new</tt> rather than as locals or global/<tt>static</tt> objects?</a></li>
<li><a href="freestore-mgmt.html#faq-16.21" title="[16.21] How do I do simple reference counting?">[16.21] How do I do simple reference counting?</a></li>
<li><a href="freestore-mgmt.html#faq-16.22" title="[16.22] How do I provide reference counting with copy-on-write semantics?">[16.22] How do I provide reference counting with copy-on-write semantics?</a></li>
<li><a href="freestore-mgmt.html#faq-16.23" title="[16.23] How do I provide reference counting with copy-on-write semantics for a hierarchy of classes?">[16.23] How do I provide reference counting with copy-on-write semantics for a hierarchy of classes?</a> <span class=Updated>&nbsp;Updated!&nbsp;</span></li>
<li><a href="freestore-mgmt.html#faq-16.24" title="[16.24] Can you absolutely prevent people from subverting the reference counting mechanism, and if so, should you?">[16.24] Can you absolutely <em>prevent</em> people from subverting the reference counting mechanism, and if so, <em>should</em> you?</a></li>
<li><a href="freestore-mgmt.html#faq-16.25" title="[16.25] Can I use a garbage collector in C++?">[16.25] Can I use a garbage collector in C++?</a></li>
<li><a href="freestore-mgmt.html#faq-16.26" title="[16.26] What are the two kinds of garbage collectors for C++?">[16.26] What are the two kinds of garbage collectors for C++?</a></li>
<li><a href="freestore-mgmt.html#faq-16.27" title="[16.27] Where can I get more info on garbage collectors for C++?">[16.27] Where can I get more info on garbage collectors for C++?</a></li>
</ul>
<p><hr>
<p><a name="faq-16.1"></a>
<div class=FaqTitle><h3>[16.1] Does <nobr><tt>delete p</tt></nobr> delete the pointer <tt>p</tt>, or the pointed-to-data <nobr><tt>*p</tt></nobr>?</h3></div>
<p>The pointed-to-data.
<p>The keyword should really be <tt>delete_the_thing_pointed_to_by</tt>.  The same
abuse of English occurs when <tt>free</tt>ing the memory pointed to by a pointer in C:
<nobr><tt>free(p)</tt></nobr> really means <nobr><tt>free_the_stuff_pointed_to_by(p)</tt></nobr>.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.2"></a>
<div class=FaqTitle><h3>[16.2] Can I <nobr><tt>free()</tt></nobr> pointers allocated with <tt>new</tt>? Can I <tt>delete</tt> pointers allocated with <nobr><tt>malloc()</tt></nobr>?</h3></div>
<p><em>No!</em>
<p>It is perfectly legal, moral, and wholesome to use <nobr><tt>malloc()</tt></nobr> and <tt>delete</tt> in
the same program, or to use <tt>new</tt> and <nobr><tt>free()</tt></nobr> in the same program.
<em>But</em> it is illegal, immoral, and despicable to call <nobr><tt>free()</tt></nobr> with a
pointer allocated via <tt>new</tt>, or to call <tt>delete</tt> on a pointer allocated via
<nobr><tt>malloc()</tt></nobr>.
<p><em>Beware!</em> I occasionally get e-mail from people telling me that it works
OK for them on machine X and compiler Y.  Just because they don't <em>see</em>
bad symptoms in a simple test case doesn't mean it won't crash in the field.
Even if they <em>know</em> it won't crash on their particular compiler doesn't
mean it will work safely on another compiler, another platform, or even
another version of the same compiler.
<p><em>Beware!</em> Sometimes people say, &quot;But I'm just working with an array of
<tt>char</tt>.&quot; Nonetheless do <em>not</em> mix <nobr><tt>malloc()</tt></nobr> and <tt>delete</tt> on the same
pointer, or <tt>new</tt> and <nobr><tt>free()</tt></nobr> on the same pointer!  If you allocated via
<nobr><tt>p = new char[n]</tt></nobr>, you <em>must</em> use <nobr><tt>delete[] p</tt></nobr>; you must
<em>not</em> use <nobr><tt>free(p)</tt></nobr>.  Or if you allocated via <nobr><tt>p =
malloc(n)</tt></nobr>, you <em>must</em> use <nobr><tt>free(p)</tt></nobr>; you must <em>not</em> use
<nobr><tt>delete[] p</tt></nobr> or <nobr><tt>delete p</tt></nobr>!  Mixing these up could cause a
catastrophic failure at runtime if the code was ported to a new machine, a new
compiler, or even a new version of the same compiler.
<p>You have been warned.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.3"></a>
<div class=FaqTitle><h3>[16.3] Why should I use <tt>new</tt> instead of trustworthy old <nobr><tt>malloc()</tt></nobr>?</h3></div>
<p>Constructors/destructors, type safety, overridability.
<ul>
<li>Constructors/destructors: unlike <nobr><tt>malloc(sizeof(Fred))</tt></nobr>,
<nobr><tt>new Fred()</tt></nobr> calls <tt>Fred</tt>'s constructor.  Similarly, <nobr><tt>delete p</tt></nobr> calls
<nobr><tt>*p</tt></nobr>'s destructor.</li>
<li>Type safety: <nobr><tt>malloc()</tt></nobr> returns a <nobr><tt>void*</tt></nobr> which isn't type safe.
<nobr><tt>new Fred()</tt></nobr> returns a pointer of the right type (a <nobr><tt>Fred*</tt></nobr>).</li>
<li>Overridability: <tt>new</tt> is an <tt>operator</tt> that can be overridden by a
class, while <nobr><tt>malloc()</tt></nobr> is not overridable on a per-class basis.</li>
</ul>
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.4"></a>
<div class=FaqTitle><h3>[16.4] Can I use <nobr><tt>realloc()</tt></nobr> on pointers allocated via <tt>new</tt>?</h3></div>
<p>No!
<p>When <nobr><tt>realloc()</tt></nobr> has to copy the allocation, it uses a <em>bitwise</em> copy
operation, which will tear many C++ objects to shreds.  C++ objects should be
allowed to copy themselves.  They use their own copy constructor or assignment
operator.
<p>Besides all that, the heap that <tt>new</tt> uses may <em>not</em> be the same as the
heap that <nobr><tt>malloc()</tt></nobr> and <nobr><tt>realloc()</tt></nobr> use!
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.5"></a>
<div class=FaqTitle><h3>[16.5] Do I need to check for <tt>NULL</tt> after <nobr><tt>p = new Fred()</tt></nobr>?</h3></div>
<p>No!  (But if you have an old compiler, you may have to
<a href="freestore-mgmt.html#faq-16.6" title="[16.6] How can I convince my (older) compiler to automatically check new to see if it returns NULL?">force the <tt>new</tt> operator to <tt>throw</tt> an
exception if it runs out of memory<!--rawtext:[16.6]:rawtext--></a>.)
<p>It turns out to be a real pain to always write explicit <tt>NULL</tt> tests after
every <tt>new</tt> allocation.  Code like the following is very tedious:
<p><div class=CodeBlock>
<tt>
&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;new&nbsp;Fred();<br>
&nbsp;if&nbsp;(p&nbsp;==&nbsp;NULL)<br>
&nbsp;&nbsp;&nbsp;throw&nbsp;std::bad_alloc();
</tt>
</div>
<p>If your compiler doesn't support (or if you refuse to use)
<a href="exceptions.html" title="[17] Exceptions and error handling">exceptions<!--rawtext:[17]:rawtext--></a>, your code might be even more tedious:
<p><div class=CodeBlock>
<tt>
&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;new&nbsp;Fred();<br>
&nbsp;if&nbsp;(p&nbsp;==&nbsp;NULL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cerr&nbsp;&lt;&lt;&nbsp;&quot;Couldn't&nbsp;allocate&nbsp;memory&nbsp;for&nbsp;a&nbsp;Fred&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br>
&nbsp;&nbsp;&nbsp;abort();<br>
&nbsp;}
</tt>
</div>
<p>Take heart.  In C++, if the runtime system cannot allocate <nobr><tt>sizeof(Fred)</tt></nobr> bytes
of memory during <nobr><tt>p = new Fred()</tt></nobr>, a <nobr><tt>std::bad_alloc</tt></nobr> exception will be
thrown.  Unlike <nobr><tt>malloc()</tt></nobr>, <tt>new</tt> <em>never</em> returns <tt>NULL</tt>!
<p>Therefore you should simply write:
<p><div class=CodeBlock>
<tt>
&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;new&nbsp;Fred();&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;need&nbsp;to&nbsp;check&nbsp;if&nbsp;<tt>p</tt>&nbsp;is&nbsp;<tt>NULL</tt></em><tt>
</tt>
</div>
<p>However, if your compiler is old, it may not yet support this.  Find out by
checking your compiler's documentation under &quot;<tt>new</tt>&quot;.  If you have an old
compiler, you may have to <a href="freestore-mgmt.html#faq-16.6" title="[16.6] How can I convince my (older) compiler to automatically check new to see if it returns NULL?">force the compiler to
have this behavior<!--rawtext:[16.6]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.6"></a>
<div class=FaqTitle><h3>[16.6] How can I convince my (older) compiler to automatically check <tt>new</tt> to see if it returns <tt>NULL</tt>?</h3></div>
<p>Eventually your compiler will.
<p>If you have an old compiler that doesn't automagically perform
<a href="freestore-mgmt.html#faq-16.5" title="[16.5] Do I need to check for NULL after p = new Fred()?">the <tt>NULL</tt> test<!--rawtext:[16.5]:rawtext--></a>, you can force the runtime
system to do the test by installing a &quot;new handler&quot; function.  Your &quot;new
handler&quot; function can do anything you want, such as <tt>throw</tt> an exception,
<tt>delete</tt> some objects and return (in which case <nobr><tt>operator new</tt></nobr> will
retry the allocation), print a message and <nobr><tt>abort()</tt></nobr> the program, etc.
<p>Here's a sample &quot;new handler&quot; that prints a message and <tt>throw</tt>s an exception.
The handler is installed using <nobr><tt>std::set_new_handler()</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;new&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;To&nbsp;get&nbsp;<nobr><tt>std::set_new_handler</tt></nobr></em><tt><br>
&nbsp;#include&nbsp;&lt;cstdlib&gt;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;To&nbsp;get&nbsp;<nobr><tt>abort()</tt></nobr></em><tt><br>
&nbsp;#include&nbsp;&lt;iostream&gt;&nbsp;&nbsp;</tt><em>//&nbsp;To&nbsp;get&nbsp;<nobr><tt>std::cerr</tt></nobr></em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;alloc_error&nbsp;:&nbsp;public&nbsp;std::exception&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;alloc_error()&nbsp;:&nbsp;exception()&nbsp;{&nbsp;}<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;void&nbsp;myNewHandler()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;This&nbsp;is&nbsp;your&nbsp;own&nbsp;handler.&nbsp;&nbsp;It&nbsp;can&nbsp;do&nbsp;anything&nbsp;you&nbsp;want.</em><tt><br>
&nbsp;&nbsp;&nbsp;throw&nbsp;alloc_error();<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::set_new_handler(myNewHandler);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Install&nbsp;your&nbsp;&quot;new&nbsp;handler&quot;</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>After the <nobr><tt>std::set_new_handler()</tt></nobr> line is executed, <nobr><tt>operator new</tt></nobr> will
call your <nobr><tt>myNewHandler()</tt></nobr> if/when it runs out of memory.  This means
that <tt>new</tt> will never return <tt>NULL</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;new&nbsp;Fred();&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;need&nbsp;to&nbsp;check&nbsp;if&nbsp;<tt>p</tt>&nbsp;is&nbsp;<tt>NULL</tt></em><tt>
</tt>
</div>
<p>Note: If your compiler doesn't support <a href="exceptions.html" title="[17] Exceptions and error handling">exception
handling<!--rawtext:[17]:rawtext--></a>, you can, as a last resort, change the line <tt>throw</tt>&nbsp;...<nobr><tt>;</tt></nobr>
to:
<p><div class=CodeBlock>
<tt>
&nbsp;std::cerr&nbsp;&lt;&lt;&nbsp;&quot;Attempt&nbsp;to&nbsp;allocate&nbsp;memory&nbsp;failed!&quot;&nbsp;&lt;&lt;&nbsp;std::endl;<br>
&nbsp;abort();
</tt>
</div>
<p>Note: If some global/static object's constructor uses <tt>new</tt>, it won't use
the <nobr><tt>myNewHandler()</tt></nobr> function since that constructor will get called
before <nobr><tt>main()</tt></nobr> begins.  Unfortunately there's no convenient way to
guarantee that the <nobr><tt>std::set_new_handler()</tt></nobr> will be called before the first
use of <tt>new</tt>.  For example, even if you put the <nobr><tt>std::set_new_handler()</tt></nobr>
call in the constructor of a global object, you still don't know if the module
(&quot;compilation unit&quot;) that contains that global object will be elaborated first
or last or somewhere inbetween.  Therefore you still don't have any guarantee
that your call of <nobr><tt>std::set_new_handler()</tt></nobr> will happen before any other
global's constructor gets invoked.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.7"></a>
<div class=FaqTitle><h3>[16.7] Do I need to check for <tt>NULL</tt> before <nobr><tt>delete p</tt></nobr>?</h3></div>
<p>No!
<p>The C++ language guarantees that <nobr><tt>delete p</tt></nobr> will do nothing if <tt>p</tt> is equal to
<tt>NULL</tt>.  Since you might get the test backwards, and since most testing
methodologies force you to explicitly test every branch point, you should
<em>not</em> put in the redundant <tt>if</tt> test.
<p>Wrong:
<p><div class=CodeBlock>
<tt>
&nbsp;if&nbsp;(p&nbsp;!=&nbsp;NULL)<br>
&nbsp;&nbsp;&nbsp;delete&nbsp;p;
</tt>
</div>
<p>Right:
<p><div class=CodeBlock>
<tt>
&nbsp;delete&nbsp;p;
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.8"></a>
<div class=FaqTitle><h3>[16.8] What are the two steps that happen when I say <nobr><tt>delete p</tt></nobr>?</h3></div>
<p><nobr><tt>delete p</tt></nobr> is a two-step process: it calls the destructor, then releases the
memory.  The code generated for <nobr><tt>delete p</tt></nobr> is functionally similar to this (assuming
<tt>p</tt> is of type <nobr><tt>Fred*</tt></nobr>):
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;Original&nbsp;code:&nbsp;<nobr><tt>delete&nbsp;p;</tt></nobr></em><tt><br>
&nbsp;if&nbsp;(p&nbsp;!=&nbsp;NULL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;p-&gt;~Fred();<br>
&nbsp;&nbsp;&nbsp;operator&nbsp;delete(p);<br>
&nbsp;}
</tt>
</div>
<p>The statement <nobr><tt>p-&gt;~Fred()</tt></nobr> calls the destructor for the <tt>Fred</tt> object
pointed to by <tt>p</tt>.
<p>The statement <nobr><tt>operator delete(p)</tt></nobr> calls the memory deallocation
primitive, <nobr><tt>void operator delete(void* p)</tt></nobr>.  This primitive is similar in
spirit to <nobr><tt>free(void* p)</tt></nobr>.  (Note, however, that these two are
<em>not</em> interchangeable; e.g., there is no guarantee that the two memory
deallocation primitives even use the same heap!)
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.9"></a>
<div class=FaqTitle><h3>[16.9] In <nobr><tt>p = new Fred()</tt></nobr>, does the <tt>Fred</tt> memory &quot;leak&quot; if the <tt>Fred</tt> constructor throws an exception?</h3></div>
<p>No.
<p>If an exception occurs during the <tt>Fred</tt> constructor of <nobr><tt>p = new Fred()</tt></nobr>,
the C++ language guarantees that the memory <nobr><tt>sizeof(Fred)</tt></nobr> bytes that were
allocated will automagically be released back to the heap.
<p>Here are the details: <nobr><tt>new Fred()</tt></nobr> is a two-step process:
<ol>
<li><nobr><tt>sizeof(Fred)</tt></nobr> bytes of memory are allocated using the primitive
<nobr><tt>void* operator new(size_t nbytes)</tt></nobr>.  This primitive is similar in spirit
to <nobr><tt>malloc(size_t nbytes)</tt></nobr>.  (Note, however, that these two are
<em>not</em> interchangeable; e.g., there is no guarantee that the two memory
allocation primitives even use the same heap!).</li>
<li>It constructs an object in that memory by calling the <tt>Fred</tt>
constructor.  The pointer returned from the first step is passed as the <tt>this</tt>
parameter to the constructor.  This step is wrapped in a <tt>try</tt> ... <tt>catch</tt>
block to handle the case when an exception is thrown during this
step.</li>
</ol>
<p>Thus the actual generated code is functionally similar to:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;Original&nbsp;code:&nbsp;<nobr><tt>Fred*&nbsp;p&nbsp;=&nbsp;new&nbsp;Fred();</tt></nobr></em><tt><br>
&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;(Fred*)&nbsp;operator&nbsp;new(sizeof(Fred));<br>
&nbsp;try&nbsp;{<br>
&nbsp;&nbsp;&nbsp;new(p)&nbsp;Fred();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<a href="dtors.html#faq-11.10" title="[11.10] What is &quot;placement new&quot; and why would I use it?">Placement&nbsp;<tt>new</tt><!--rawtext:[11.10]:rawtext--></a></em><tt><br>
&nbsp;}&nbsp;catch&nbsp;(...)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;operator&nbsp;delete(p);&nbsp;&nbsp;</tt><em>//&nbsp;Deallocate&nbsp;the&nbsp;memory</em><tt><br>
&nbsp;&nbsp;&nbsp;throw;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Re-throw&nbsp;the&nbsp;exception</em><tt><br>
&nbsp;}
</tt>
</div>
<p>The statement marked &quot;<a href="dtors.html#faq-11.10" title="[11.10] What is &quot;placement new&quot; and why would I use it?">Placement <tt>new</tt><!--rawtext:[11.10]:rawtext--></a>&quot; calls the
<tt>Fred</tt> constructor.  The pointer <tt>p</tt> becomes the <tt>this</tt> pointer inside the
constructor, <nobr><tt>Fred::Fred()</tt></nobr>.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.10"></a>
<div class=FaqTitle><h3>[16.10] How do I allocate / unallocate an array of things?</h3></div>
<p>Use <nobr><tt>p = new T[n]</tt></nobr> and <nobr><tt>delete[] p</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;new&nbsp;Fred[100];<br>
&nbsp;</tt><em>...</em><tt><br>
&nbsp;delete[]&nbsp;p;
</tt>
</div>
<p>Any time you allocate an array of objects via <tt>new</tt> (usually with the
<nobr><tt>[</tt></nobr><em>n</em><nobr><tt>]</tt></nobr> in the <tt>new</tt> expression), you <em>must</em> use
<nobr><tt>[]</tt></nobr> in the <tt>delete</tt> statement.  This syntax is necessary because there
is no syntactic difference between a pointer to a thing and a pointer to an
array of things (something we inherited from C).
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.11"></a>
<div class=FaqTitle><h3>[16.11] What if I forget the <nobr><tt>[]</tt></nobr> when <tt>delete</tt>ing array allocated via <nobr><tt>new T[n]</tt></nobr>?</h3></div>
<p>All life comes to a catastrophic end.
<p>It is the programmer's &#151;not the compiler's&#151; responsibility to get the
connection between <nobr><tt>new T[n]</tt></nobr> and <nobr><tt>delete[] p</tt></nobr> correct.  If you get
it wrong, neither a compile-time nor a run-time error message will be generated
by the compiler.  Heap corruption is a likely result.  Or worse.  Your program
will probably die.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.12"></a>
<div class=FaqTitle><h3>[16.12] Can I drop the <nobr><tt>[]</tt></nobr> when <tt>delete</tt>ing array of some built-in type (<tt>char</tt>, <tt>int</tt>, etc)?</h3></div>
<p><em>No!</em>
<p>Sometimes programmers think that the <nobr><tt>[]</tt></nobr> in the <nobr><tt>delete[] p</tt></nobr> only exists
so the compiler will call the appropriate destructors for all elements in the
array.  Because of this reasoning, they assume that an array of some built-in
type such as <tt>char</tt> or <tt>int</tt> can be <tt>delete</tt>d without the <nobr><tt>[]</tt></nobr>.  E.g., they
assume the following is valid code:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;userCode(int&nbsp;n)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;char*&nbsp;p&nbsp;=&nbsp;new&nbsp;char[n];<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;delete&nbsp;p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<big>&#8592;</big>&nbsp;ERROR!&nbsp;Should&nbsp;be&nbsp;<nobr><tt>delete[]&nbsp;p</tt></nobr>&nbsp;!</em><tt><br>
&nbsp;}
</tt>
</div>
<p>But the above code is wrong, and it can cause a disaster at runtime.  In
particular, the code that's called for <nobr><tt>delete p</tt></nobr> is <nobr><tt>operator
delete(void*)</tt></nobr>, but the code that's called for <nobr><tt>delete[] p</tt></nobr> is
<nobr><tt>operator delete[](void*)</tt></nobr>.  The default behavior for the latter is to
call the former, but users are allowed to replace the latter with a different
behavior (in which case they would normally also replace the corresponding
<tt>new</tt> code in <nobr><tt>operator new[](size_t)</tt></nobr>).  If they replaced the
<nobr><tt>delete[]</tt></nobr> code so it wasn't compatible with the <tt>delete</tt> code, and you
called the wrong one (i.e., if you said <nobr><tt>delete p</tt></nobr> rather than
<nobr><tt>delete[] p</tt></nobr>), you could end up with a disaster at runtime.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.13"></a>
<div class=FaqTitle><h3>[16.13] After <nobr><tt>p = new Fred[n]</tt></nobr>, how does the compiler know there are <tt>n</tt> objects to be destructed during <nobr><tt>delete[] p</tt></nobr>?</h3></div>
<p>Short answer: Magic.
<p>Long answer: The run-time system stores the number of objects, <tt>n</tt>, somewhere
where it can be retrieved if you only know the pointer, <tt>p</tt>.  There are two
popular techniques that do this.  Both these techniques are in use by
commercial grade compilers, both have tradeoffs, and neither is perfect.  These
techniques are:
<ul>
<li><a href="compiler-dependencies.html#faq-37.7" title="[37.7] How do compilers use &quot;over-allocation&quot; to remember the number of elements in an allocated array?">Over-allocate the array and
put <tt>n</tt> just to the left of the first <tt>Fred</tt> object<!--rawtext:[37.7]:rawtext--></a>.</li>
<li><a href="compiler-dependencies.html#faq-37.8" title="[37.8] How do compilers use an &quot;associative array&quot; to remember the number of elements in an allocated array?">Use an associative array
with <tt>p</tt> as the key and <tt>n</tt> as the value<!--rawtext:[37.8]:rawtext--></a>.</li>
</ul>
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.14"></a>
<div class=FaqTitle><h3>[16.14] Is it legal (and moral) for a member function to say <nobr><tt>delete this</tt></nobr>?</h3></div>
<p>As long as you're careful, it's OK for an object to commit suicide
(<tt>delete</tt> <tt>this</tt>).
<p>Here's how I define &quot;careful&quot;:
<ol>
<li>You must be absolutely 100% positive sure that <tt>this</tt> object was
allocated via <tt>new</tt> (not by <nobr><tt>new[]</tt></nobr>, nor by <a href="dtors.html#faq-11.10" title="[11.10] What is &quot;placement new&quot; and why would I use it?">placement
<tt>new</tt><!--rawtext:[11.10]:rawtext--></a>, nor a local object on the stack, nor a global, nor a
member of another object; but by plain ordinary <tt>new</tt>).</li>
<li>You must be absolutely 100% positive sure that your member function
will be the last member function invoked on <tt>this</tt> object.</li>
<li>You must be absolutely 100% positive sure that the rest of your
member function (after the <tt>delete</tt> <tt>this</tt> line) doesn't touch any piece of
<tt>this</tt> object (including calling any other member functions or touching any
data members).</li>
<li>You must be absolutely 100% positive sure that no one even touches
the <tt>this</tt> pointer itself after the <tt>delete</tt> <tt>this</tt> line.  In other words, you
must not examine it, compare it with another pointer, compare it with <tt>NULL</tt>,
print it, cast it, do anything with it.</li>
</ol>
<p>Naturally the usual caveats apply in cases where your <tt>this</tt> pointer is a
pointer to a base class when you don't have a <a href="virtual-functions.html#faq-20.5" title="[20.5] When should my destructor be virtual?">virtual
destructor<!--rawtext:[20.5]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.15"></a>
<div class=FaqTitle><h3>[16.15] How do I allocate multidimensional arrays using <tt>new</tt>?</h3></div>
<p>There are many ways to do this, depending on how flexible you want the array
sizing to be.  On one extreme, if you know all the dimensions at compile-time,
you can allocate multidimensional arrays statically (as in C):
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{&nbsp;</tt><em>/*...*/</em><tt>&nbsp;};<br>
&nbsp;void&nbsp;someFunction(Fred&amp;&nbsp;fred);<br>
&nbsp;<br>
&nbsp;void&nbsp;manipulateArray()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;const&nbsp;unsigned&nbsp;nrows&nbsp;=&nbsp;10;&nbsp;&nbsp;</tt><em>//&nbsp;Num&nbsp;rows&nbsp;is&nbsp;a&nbsp;compile-time&nbsp;constant</em><tt><br>
&nbsp;&nbsp;&nbsp;const&nbsp;unsigned&nbsp;ncols&nbsp;=&nbsp;20;&nbsp;&nbsp;</tt><em>//&nbsp;Num&nbsp;columns&nbsp;is&nbsp;a&nbsp;compile-time&nbsp;constant</em><tt><br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;matrix[nrows][ncols];<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nrows;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;ncols;&nbsp;++j)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Here's&nbsp;the&nbsp;way&nbsp;you&nbsp;access&nbsp;the&nbsp;<nobr><tt>(i,j)</tt></nobr>&nbsp;element:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;someFunction(&nbsp;matrix[i][j]&nbsp;);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;You&nbsp;can&nbsp;safely&nbsp;&quot;return&quot;&nbsp;without&nbsp;any&nbsp;special&nbsp;<tt>delete</tt>&nbsp;code:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(today&nbsp;==&nbsp;&quot;Tuesday&quot;&nbsp;&amp;&amp;&nbsp;moon.isFull())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Quit&nbsp;early&nbsp;on&nbsp;Tuesdays&nbsp;when&nbsp;the&nbsp;moon&nbsp;is&nbsp;full</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;explicit&nbsp;<tt>delete</tt>&nbsp;code&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;function&nbsp;either</em><tt><br>
&nbsp;}
</tt>
</div>
<p>More commonly, the size of the matrix isn't known until run-time but you know
that it will be rectangular.  In this case you need to use the heap
(&quot;freestore&quot;), but at least you are able to allocate all the elements in one
freestore chunk.
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;manipulateArray(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Fred*&nbsp;matrix&nbsp;=&nbsp;new&nbsp;Fred[nrows&nbsp;*&nbsp;ncols];<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Since&nbsp;we&nbsp;used&nbsp;a&nbsp;simple&nbsp;pointer&nbsp;above,&nbsp;we&nbsp;need&nbsp;to&nbsp;be&nbsp;VERY</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;careful&nbsp;to&nbsp;avoid&nbsp;skipping&nbsp;over&nbsp;the&nbsp;<tt>delete</tt>&nbsp;code.</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;That's&nbsp;why&nbsp;we&nbsp;catch&nbsp;all&nbsp;exceptions:</em><tt><br>
&nbsp;&nbsp;&nbsp;try&nbsp;{<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Here's&nbsp;how&nbsp;to&nbsp;access&nbsp;the&nbsp;<nobr><tt>(i,j)</tt></nobr>&nbsp;element:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nrows;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;ncols;&nbsp;++j)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;someFunction(&nbsp;matrix[i*ncols&nbsp;+&nbsp;j]&nbsp;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;If&nbsp;you&nbsp;want&nbsp;to&nbsp;quit&nbsp;early&nbsp;on&nbsp;Tuesdays&nbsp;when&nbsp;the&nbsp;moon&nbsp;is&nbsp;full,</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;make&nbsp;sure&nbsp;to&nbsp;do&nbsp;the&nbsp;<tt>delete</tt>&nbsp;along&nbsp;ALL&nbsp;return&nbsp;paths:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(today&nbsp;==&nbsp;&quot;Tuesday&quot;&nbsp;&amp;&amp;&nbsp;moon.isFull())&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>...insert&nbsp;code&nbsp;here&nbsp;to&nbsp;fiddle&nbsp;with&nbsp;the&nbsp;matrix...</em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;catch&nbsp;(...)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Make&nbsp;sure&nbsp;to&nbsp;do&nbsp;the&nbsp;<tt>delete</tt>&nbsp;when&nbsp;an&nbsp;exception&nbsp;is&nbsp;thrown:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Re-throw&nbsp;the&nbsp;current&nbsp;exception</em><tt><br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Make&nbsp;sure&nbsp;to&nbsp;do&nbsp;the&nbsp;<tt>delete</tt>&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;function&nbsp;too:</em><tt><br>
&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix;<br>
&nbsp;}
</tt>
</div>
<p>Finally at the other extreme, you may not even be guaranteed that the matrix is
rectangular.  For example, if each row could have a different length, you'll
need to allocate each row individually.  In the following function,
<nobr><tt>ncols[i]</tt></nobr> is the number of columns in row number <tt>i</tt>, where
<tt>i</tt> varies between <tt>0</tt> and <nobr><tt>nrows-1</tt></nobr> inclusive.
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;manipulateArray(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols[])<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;typedef&nbsp;Fred*&nbsp;FredPtr;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;There&nbsp;will&nbsp;not&nbsp;be&nbsp;a&nbsp;leak&nbsp;if&nbsp;the&nbsp;following&nbsp;throws&nbsp;an&nbsp;exception:</em><tt><br>
&nbsp;&nbsp;&nbsp;FredPtr*&nbsp;matrix&nbsp;=&nbsp;new&nbsp;FredPtr[nrows];<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Set&nbsp;each&nbsp;element&nbsp;to&nbsp;<tt>NULL</tt>&nbsp;in&nbsp;case&nbsp;there&nbsp;is&nbsp;an&nbsp;exception&nbsp;later.</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;(See&nbsp;comments&nbsp;at&nbsp;the&nbsp;top&nbsp;of&nbsp;the&nbsp;<tt>try</tt>&nbsp;block&nbsp;for&nbsp;rationale.)</em><tt><br>
&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nrows;&nbsp;++i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix[i]&nbsp;=&nbsp;NULL;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Since&nbsp;we&nbsp;used&nbsp;a&nbsp;simple&nbsp;pointer&nbsp;above,&nbsp;we&nbsp;need&nbsp;to&nbsp;be</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;VERY&nbsp;careful&nbsp;to&nbsp;avoid&nbsp;skipping&nbsp;over&nbsp;the&nbsp;<tt>delete</tt>&nbsp;code.</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;That's&nbsp;why&nbsp;we&nbsp;catch&nbsp;all&nbsp;exceptions:</em><tt><br>
&nbsp;&nbsp;&nbsp;try&nbsp;{<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Next&nbsp;we&nbsp;populate&nbsp;the&nbsp;array.&nbsp;&nbsp;If&nbsp;one&nbsp;of&nbsp;these&nbsp;throws,&nbsp;all</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;the&nbsp;allocated&nbsp;elements&nbsp;will&nbsp;be&nbsp;deleted&nbsp;(see&nbsp;<tt>catch</tt>&nbsp;below).</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nrows;&nbsp;++i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matrix[i]&nbsp;=&nbsp;new&nbsp;Fred[&nbsp;ncols[i]&nbsp;];<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Here's&nbsp;how&nbsp;to&nbsp;access&nbsp;the&nbsp;<nobr><tt>(i,j)</tt></nobr>&nbsp;element:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nrows;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;ncols[i];&nbsp;++j)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;someFunction(&nbsp;matrix[i][j]&nbsp;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;If&nbsp;you&nbsp;want&nbsp;to&nbsp;quit&nbsp;early&nbsp;on&nbsp;Tuesdays&nbsp;when&nbsp;the&nbsp;moon&nbsp;is&nbsp;full,</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;make&nbsp;sure&nbsp;to&nbsp;do&nbsp;the&nbsp;<tt>delete</tt>&nbsp;along&nbsp;ALL&nbsp;return&nbsp;paths:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(today&nbsp;==&nbsp;&quot;Tuesday&quot;&nbsp;&amp;&amp;&nbsp;moon.isFull())&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;nrows;&nbsp;i&nbsp;&gt;&nbsp;0;&nbsp;--i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix[i-1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>...insert&nbsp;code&nbsp;here&nbsp;to&nbsp;fiddle&nbsp;with&nbsp;the&nbsp;matrix...</em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;catch&nbsp;(...)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Make&nbsp;sure&nbsp;to&nbsp;do&nbsp;the&nbsp;<tt>delete</tt>&nbsp;when&nbsp;an&nbsp;exception&nbsp;is&nbsp;thrown:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Note&nbsp;that&nbsp;some&nbsp;of&nbsp;these&nbsp;<nobr><tt>matrix[</tt>...<tt>]</tt></nobr>&nbsp;pointers&nbsp;might&nbsp;be</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>NULL</tt>,&nbsp;but&nbsp;that's&nbsp;okay&nbsp;since&nbsp;it's&nbsp;legal&nbsp;to&nbsp;<tt>delete</tt>&nbsp;<tt>NULL</tt>.</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;nrows;&nbsp;i&nbsp;&gt;&nbsp;0;&nbsp;--i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix[i-1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Re-throw&nbsp;the&nbsp;current&nbsp;exception</em><tt><br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Make&nbsp;sure&nbsp;to&nbsp;do&nbsp;the&nbsp;<tt>delete</tt>&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;function&nbsp;too.</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Note&nbsp;that&nbsp;deletion&nbsp;is&nbsp;the&nbsp;opposite&nbsp;order&nbsp;of&nbsp;allocation:</em><tt><br>
&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;nrows;&nbsp;i&nbsp;&gt;&nbsp;0;&nbsp;--i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix[i-1];<br>
&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix;<br>
&nbsp;}
</tt>
</div>
<p>Note the funny use of <nobr><tt>matrix[i-1]</tt></nobr> in the deletion process.  This
prevents wrap-around of the <tt>unsigned</tt> value when <tt>i</tt> goes one step
below zero.
<p>Finally, note that <a href="containers-and-templates.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">pointers and arrays are evil<!--rawtext:[34.1]:rawtext--></a>.
It is normally much better to encapsulate your pointers in a class that has a
safe and simple interface.  <a href="freestore-mgmt.html#faq-16.16" title="[16.16] But the previous FAQ's code is SOOOO tricky and error prone! Isn't there a simpler way?">The following FAQ<!--rawtext:[16.16]:rawtext--></a>
shows how to do this.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.16"></a>
<div class=FaqTitle><h3>[16.16] But the previous FAQ's code is SOOOO tricky and error prone! Isn't there a simpler way? <span class=Updated>&nbsp;Updated!&nbsp;</span></h3></div>
<small><em>[Recently fixed a memory leak in the ctor when <tt>nrows</tt> or <tt>ncols</tt> was zero thanks to <a href="mailto:chris.carton@braintree.com.au" title="chris.carton@braintree.com.au">Chris Carton</a> (in 5/03).  <a href="freestore-mgmt.html#faq-16.18" title="[16.18] What's another way to build a Matrix template?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[16.18]:rawtext--></a>.]</em></small>
<p>Yep.
<p>The reason the code in <a href="freestore-mgmt.html#faq-16.15" title="[16.15] How do I allocate multidimensional arrays using new?">the previous FAQ<!--rawtext:[16.15]:rawtext--></a> was so
tricky and error prone was that it used pointers, and we know that
<a href="containers-and-templates.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">pointers and arrays are evil<!--rawtext:[34.1]:rawtext--></a>.  The solution is to
encapsulate your pointers in a class that has a safe and simple interface.  For
example, we can define a <tt>Matrix</tt> class that handles a rectangular
matrix so our user code will be vastly simplified when compared to the
<a href="freestore-mgmt.html#faq-16.15" title="[16.15] How do I allocate multidimensional arrays using new?">the rectangular matrix code from the previous FAQ<!--rawtext:[16.15]:rawtext--></a>:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;The&nbsp;code&nbsp;for&nbsp;<nobr><tt>class&nbsp;Matrix</tt></nobr>&nbsp;is&nbsp;shown&nbsp;below...</em><tt><br>
&nbsp;void&nbsp;someFunction(Fred&amp;&nbsp;fred);<br>
&nbsp;<br>
&nbsp;void&nbsp;manipulateArray(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Matrix&nbsp;matrix(nrows,&nbsp;ncols);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Construct&nbsp;a&nbsp;<tt>Matrix</tt>&nbsp;called&nbsp;<tt>matrix</tt></em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nrows;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;ncols;&nbsp;++j)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Here's&nbsp;the&nbsp;way&nbsp;you&nbsp;access&nbsp;the&nbsp;<nobr><tt>(i,j)</tt></nobr>&nbsp;element:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;someFunction(&nbsp;matrix(i,j)&nbsp;);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;You&nbsp;can&nbsp;safely&nbsp;&quot;return&quot;&nbsp;without&nbsp;any&nbsp;special&nbsp;<tt>delete</tt>&nbsp;code:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(today&nbsp;==&nbsp;&quot;Tuesday&quot;&nbsp;&amp;&amp;&nbsp;moon.isFull())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Quit&nbsp;early&nbsp;on&nbsp;Tuesdays&nbsp;when&nbsp;the&nbsp;moon&nbsp;is&nbsp;full</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;explicit&nbsp;<tt>delete</tt>&nbsp;code&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;function&nbsp;either</em><tt><br>
&nbsp;}
</tt>
</div>
<p>The main thing to notice is the lack of clean-up code.  For example, there
aren't any <tt>delete</tt> statements in the above code, yet there will be <em>no</em>
memory leaks, assuming only that the <tt>Matrix</tt> destructor does its job
correctly.
<p>Here's the <tt>Matrix</tt> code that makes the above possible:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Matrix&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Matrix(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols);<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Throws&nbsp;a&nbsp;<tt>BadSize</tt>&nbsp;object&nbsp;if&nbsp;either&nbsp;size&nbsp;is&nbsp;zero</em><tt><br>
&nbsp;&nbsp;&nbsp;class&nbsp;BadSize&nbsp;{&nbsp;};<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Based&nbsp;on&nbsp;the&nbsp;<a href="coding-standards.html#faq-27.9" title="[27.9] Are there any lint-like guidelines for C++?">Law&nbsp;Of&nbsp;The&nbsp;Big&nbsp;Three<!--rawtext:[27.9]:rawtext--></a>:</em><tt><br>
&nbsp;&nbsp;~Matrix();<br>
&nbsp;&nbsp;&nbsp;Matrix(const&nbsp;Matrix&amp;&nbsp;m);<br>
&nbsp;&nbsp;&nbsp;Matrix&amp;&nbsp;operator=&nbsp;(const&nbsp;Matrix&amp;&nbsp;m);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Access&nbsp;methods&nbsp;to&nbsp;get&nbsp;the&nbsp;<nobr><tt>(i,j)</tt></nobr>&nbsp;element:</em><tt><br>
&nbsp;&nbsp;&nbsp;Fred&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operator()&nbsp;(unsigned&nbsp;i,&nbsp;unsigned&nbsp;j);<br>
&nbsp;&nbsp;&nbsp;const&nbsp;Fred&amp;&nbsp;operator()&nbsp;(unsigned&nbsp;i,&nbsp;unsigned&nbsp;j)&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;These&nbsp;throw&nbsp;a&nbsp;<tt>BoundsViolation</tt>&nbsp;object&nbsp;if&nbsp;<tt>i</tt>&nbsp;or&nbsp;<tt>j</tt>&nbsp;is&nbsp;too&nbsp;big</em><tt><br>
&nbsp;&nbsp;&nbsp;class&nbsp;BoundsViolation&nbsp;{&nbsp;};<br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;Fred*&nbsp;data_;<br>
&nbsp;&nbsp;&nbsp;unsigned&nbsp;nrows_,&nbsp;ncols_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;inline&nbsp;Fred&amp;&nbsp;Matrix::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;nrows_&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;ncols_)&nbsp;throw&nbsp;BoundsViolation();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[row*ncols_&nbsp;+&nbsp;col];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;const&nbsp;Fred&amp;&nbsp;Matrix::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;nrows_&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;ncols_)&nbsp;throw&nbsp;BoundsViolation();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[row*ncols_&nbsp;+&nbsp;col];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Matrix::Matrix(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;data_&nbsp;&nbsp;(NULL),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrows_&nbsp;(nrows),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ncols_&nbsp;(ncols)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(nrows&nbsp;==&nbsp;0&nbsp;||&nbsp;ncols&nbsp;==&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;BadSize();<br>
&nbsp;&nbsp;&nbsp;data_&nbsp;=&nbsp;new&nbsp;Fred[nrows&nbsp;*&nbsp;ncols];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Matrix::~Matrix()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;delete[]&nbsp;data_;<br>
&nbsp;}
</tt>
</div>
<p>Note that the above <tt>Matrix</tt> class accomplishes two things: it moves
some tricky memory management code from the user code (e.g., <nobr><tt>main()</tt></nobr>)
to the class, and it reduces the overall bulk of program.  The latter point is
important.  For example, assuming <tt>Matrix</tt> is even mildly reusable,
moving complexity from the users [plural] of <tt>Matrix</tt> into
<tt>Matrix</tt> itself [singular] is equivalent to moving complexity from the
many to the few.  Anyone who's seen <em>Star Trek 2</em> knows that the good of
the many outweighs the good of the few... or the one.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.17"></a>
<div class=FaqTitle><h3>[16.17] But the above <tt>Matrix</tt> class is specific to <tt>Fred</tt>! Isn't there a way to make it generic?</h3></div>
<p>Yep; just use <a href="containers-and-templates.html" title="[34] Container classes and templates">templates<!--rawtext:[34]:rawtext--></a>:
<p>Here's how this can be used:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&quot;Fred.hpp&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;To&nbsp;get&nbsp;the&nbsp;definition&nbsp;for&nbsp;<nobr><tt>class&nbsp;Fred</tt></nobr></em><tt><br>
&nbsp;<br>
&nbsp;</tt><em>//&nbsp;The&nbsp;code&nbsp;for&nbsp;<nobr><tt>Matrix&lt;T&gt;</tt></nobr>&nbsp;is&nbsp;shown&nbsp;below...</em><tt><br>
&nbsp;void&nbsp;someFunction(Fred&amp;&nbsp;fred);<br>
&nbsp;<br>
&nbsp;void&nbsp;manipulateArray(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Matrix&lt;Fred&gt;&nbsp;matrix(nrows,&nbsp;ncols);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Construct&nbsp;a&nbsp;<nobr><tt>Matrix&lt;Fred&gt;</tt></nobr>&nbsp;called&nbsp;<tt>matrix</tt></em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nrows;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;ncols;&nbsp;++j)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Here's&nbsp;the&nbsp;way&nbsp;you&nbsp;access&nbsp;the&nbsp;<nobr><tt>(i,j)</tt></nobr>&nbsp;element:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;someFunction(&nbsp;matrix(i,j)&nbsp;);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;You&nbsp;can&nbsp;safely&nbsp;&quot;return&quot;&nbsp;without&nbsp;any&nbsp;special&nbsp;<tt>delete</tt>&nbsp;code:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(today&nbsp;==&nbsp;&quot;Tuesday&quot;&nbsp;&amp;&amp;&nbsp;moon.isFull())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Quit&nbsp;early&nbsp;on&nbsp;Tuesdays&nbsp;when&nbsp;the&nbsp;moon&nbsp;is&nbsp;full</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;explicit&nbsp;<tt>delete</tt>&nbsp;code&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;function&nbsp;either</em><tt><br>
&nbsp;}
</tt>
</div>
<p>Now it's easy to use <nobr><tt>Matrix&lt;T&gt;</tt></nobr> for things other than <tt>Fred</tt>.  For
example, the following uses a <tt>Matrix</tt> of <nobr><tt>std::string</tt></nobr> (where
<nobr><tt>std::string</tt></nobr> is the standard string class):
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;string&gt;<br>
&nbsp;<br>
&nbsp;void&nbsp;someFunction(std::string&amp;&nbsp;s);<br>
&nbsp;<br>
&nbsp;void&nbsp;manipulateArray(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Matrix&lt;std::string&gt;&nbsp;matrix(nrows,&nbsp;ncols);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Construct&nbsp;a&nbsp;<nobr><tt>Matrix&lt;std::string&gt;</tt></nobr></em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nrows;&nbsp;++i)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;ncols;&nbsp;++j)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Here's&nbsp;the&nbsp;way&nbsp;you&nbsp;access&nbsp;the&nbsp;<nobr><tt>(i,j)</tt></nobr>&nbsp;element:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;someFunction(&nbsp;matrix(i,j)&nbsp;);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;You&nbsp;can&nbsp;safely&nbsp;&quot;return&quot;&nbsp;without&nbsp;any&nbsp;special&nbsp;<tt>delete</tt>&nbsp;code:</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(today&nbsp;==&nbsp;&quot;Tuesday&quot;&nbsp;&amp;&amp;&nbsp;moon.isFull())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Quit&nbsp;early&nbsp;on&nbsp;Tuesdays&nbsp;when&nbsp;the&nbsp;moon&nbsp;is&nbsp;full</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;explicit&nbsp;<tt>delete</tt>&nbsp;code&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;function&nbsp;either</em><tt><br>
&nbsp;}
</tt>
</div>
<p>You can thus get an entire <em>family</em> of classes from a
<a href="containers-and-templates.html" title="[34] Container classes and templates">template<!--rawtext:[34]:rawtext--></a>.  For example,
<nobr><tt>Matrix&lt;Fred&gt;</tt></nobr>, <nobr><tt>Matrix&lt;std::string&gt;</tt></nobr>, <nobr><tt>Matrix&lt;
Matrix&lt;std::string&gt; &gt;</tt></nobr>, etc.
<p>Here's one way that the <a href="containers-and-templates.html" title="[34] Container classes and templates">template<!--rawtext:[34]:rawtext--></a> can be implemented:
<p><div class=CodeBlock>
<tt>
&nbsp;template&lt;class&nbsp;T&gt;&nbsp;&nbsp;</tt><em>//&nbsp;See&nbsp;<a href="containers-and-templates.html" title="[34] Container classes and templates">section&nbsp;on&nbsp;templates<!--rawtext:[34]:rawtext--></a>&nbsp;for&nbsp;more</em><tt><br>
&nbsp;class&nbsp;Matrix&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Matrix(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols);<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Throws&nbsp;a&nbsp;<tt>BadSize</tt>&nbsp;object&nbsp;if&nbsp;either&nbsp;size&nbsp;is&nbsp;zero</em><tt><br>
&nbsp;&nbsp;&nbsp;class&nbsp;BadSize&nbsp;{&nbsp;};<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Based&nbsp;on&nbsp;the&nbsp;<a href="coding-standards.html#faq-27.9" title="[27.9] Are there any lint-like guidelines for C++?">Law&nbsp;Of&nbsp;The&nbsp;Big&nbsp;Three<!--rawtext:[27.9]:rawtext--></a>:</em><tt><br>
&nbsp;&nbsp;~Matrix();<br>
&nbsp;&nbsp;&nbsp;Matrix(const&nbsp;Matrix&lt;T&gt;&amp;&nbsp;m);<br>
&nbsp;&nbsp;&nbsp;Matrix&lt;T&gt;&amp;&nbsp;operator=&nbsp;(const&nbsp;Matrix&lt;T&gt;&amp;&nbsp;m);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Access&nbsp;methods&nbsp;to&nbsp;get&nbsp;the&nbsp;<nobr><tt>(i,j)</tt></nobr>&nbsp;element:</em><tt><br>
&nbsp;&nbsp;&nbsp;T&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operator()&nbsp;(unsigned&nbsp;i,&nbsp;unsigned&nbsp;j);<br>
&nbsp;&nbsp;&nbsp;const&nbsp;T&amp;&nbsp;operator()&nbsp;(unsigned&nbsp;i,&nbsp;unsigned&nbsp;j)&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;These&nbsp;throw&nbsp;a&nbsp;<tt>BoundsViolation</tt>&nbsp;object&nbsp;if&nbsp;<tt>i</tt>&nbsp;or&nbsp;<tt>j</tt>&nbsp;is&nbsp;too&nbsp;big</em><tt><br>
&nbsp;&nbsp;&nbsp;class&nbsp;BoundsViolation&nbsp;{&nbsp;};<br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;T*&nbsp;data_;<br>
&nbsp;&nbsp;&nbsp;unsigned&nbsp;nrows_,&nbsp;ncols_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;<br>
&nbsp;inline&nbsp;T&amp;&nbsp;Matrix&lt;T&gt;::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;nrows_&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;ncols_)&nbsp;throw&nbsp;BoundsViolation();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[row*ncols_&nbsp;+&nbsp;col];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;<br>
&nbsp;inline&nbsp;const&nbsp;T&amp;&nbsp;Matrix&lt;T&gt;::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;nrows_&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;ncols_)&nbsp;throw&nbsp;BoundsViolation();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[row*ncols_&nbsp;+&nbsp;col];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;<br>
&nbsp;inline&nbsp;Matrix&lt;T&gt;::Matrix(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;data_&nbsp;&nbsp;(new&nbsp;T[nrows&nbsp;*&nbsp;ncols])<br>
&nbsp;&nbsp;&nbsp;,&nbsp;nrows_&nbsp;(nrows)<br>
&nbsp;&nbsp;&nbsp;,&nbsp;ncols_&nbsp;(ncols)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(nrows&nbsp;==&nbsp;0&nbsp;||&nbsp;ncols&nbsp;==&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;BadSize();<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;<br>
&nbsp;inline&nbsp;Matrix&lt;T&gt;::~Matrix()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;delete[]&nbsp;data_;<br>
&nbsp;}
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.18"></a>
<div class=FaqTitle><h3>[16.18] What's another way to build a <tt>Matrix</tt> template? <span class=Updated>&nbsp;Updated!&nbsp;</span></h3></div>
<small><em>[Recently added methods <nobr><tt>nrows()</tt></nobr> and <nobr><tt>ncols()</tt></nobr> thanks to <a href="mailto:cjmackie@Princeton.edu" title="cjmackie@Princeton.edu">Christopher Mackie</a> and <a href="http://web.tiscali.it/fanelia/sendmail.html" title="web.tiscali.it/fanelia/sendmail.html" target='_blank'>Paolo Copello</a>; inserted <nobr><tt>std::</tt></nobr> in front of <tt>vector</tt> a few times thanks to <a href="mailto:fco.osorio@gmx.net" title="fco.osorio@gmx.net">Francisco Osorio G</a> (in 4/03).  <a href="freestore-mgmt.html#faq-16.23" title="[16.23] How do I provide reference counting with copy-on-write semantics for a hierarchy of classes?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[16.23]:rawtext--></a>.]</em></small>
<p>Use the standard <tt>vector</tt> template, and make a <tt>vector</tt> of
<tt>vector</tt>.
<p>The following uses a <nobr><tt>std::vector&lt;std::vector&lt;T&gt; &gt;</tt></nobr> (note the space between the
two <nobr><tt>&gt;</tt></nobr> symbols).
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;vector&gt;<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;&nbsp;&nbsp;</tt><em>//&nbsp;See&nbsp;<a href="containers-and-templates.html" title="[34] Container classes and templates">section&nbsp;on&nbsp;templates<!--rawtext:[34]:rawtext--></a>&nbsp;for&nbsp;more</em><tt><br>
&nbsp;class&nbsp;Matrix&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Matrix(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols);<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Throws&nbsp;a&nbsp;<tt>BadSize</tt>&nbsp;object&nbsp;if&nbsp;either&nbsp;size&nbsp;is&nbsp;zero</em><tt><br>
&nbsp;&nbsp;&nbsp;class&nbsp;BadSize&nbsp;{&nbsp;};<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;need&nbsp;for&nbsp;any&nbsp;of&nbsp;<a href="coding-standards.html#faq-27.9" title="[27.9] Are there any lint-like guidelines for C++?">The&nbsp;Big&nbsp;Three<!--rawtext:[27.9]:rawtext--></a>!</em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Access&nbsp;methods&nbsp;to&nbsp;get&nbsp;the&nbsp;<nobr><tt>(i,j)</tt></nobr>&nbsp;element:</em><tt><br>
&nbsp;&nbsp;&nbsp;T&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operator()&nbsp;(unsigned&nbsp;i,&nbsp;unsigned&nbsp;j);<br>
&nbsp;&nbsp;&nbsp;const&nbsp;T&amp;&nbsp;operator()&nbsp;(unsigned&nbsp;i,&nbsp;unsigned&nbsp;j)&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;These&nbsp;throw&nbsp;a&nbsp;<tt>BoundsViolation</tt>&nbsp;object&nbsp;if&nbsp;<tt>i</tt>&nbsp;or&nbsp;<tt>j</tt>&nbsp;is&nbsp;too&nbsp;big</em><tt><br>
&nbsp;&nbsp;&nbsp;class&nbsp;BoundsViolation&nbsp;{&nbsp;};<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;unsigned&nbsp;nrows()&nbsp;const;&nbsp;&nbsp;</tt><em>//&nbsp;#rows&nbsp;in&nbsp;this&nbsp;matrix</em><tt><br>
&nbsp;&nbsp;&nbsp;unsigned&nbsp;ncols()&nbsp;const;&nbsp;&nbsp;</tt><em>//&nbsp;#columns&nbsp;in&nbsp;this&nbsp;matrix</em><tt><br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;std::vector&lt;std::vector&lt;T&gt;&nbsp;&gt;&nbsp;data_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;<br>
&nbsp;inline&nbsp;unsigned&nbsp;Matrix&lt;T&gt;::nrows()&nbsp;const<br>
&nbsp;{&nbsp;return&nbsp;data_.size();&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;<br>
&nbsp;inline&nbsp;unsigned&nbsp;Matrix&lt;T&gt;::ncols()&nbsp;const<br>
&nbsp;{&nbsp;return&nbsp;data_[0].size();&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;<br>
&nbsp;inline&nbsp;T&amp;&nbsp;Matrix&lt;T&gt;::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;nrows()&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;ncols())&nbsp;throw&nbsp;BoundsViolation();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[row][col];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;<br>
&nbsp;inline&nbsp;const&nbsp;T&amp;&nbsp;Matrix&lt;T&gt;::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;nrows()&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;ncols())&nbsp;throw&nbsp;BoundsViolation();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[row][col];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;template&lt;class&nbsp;T&gt;<br>
&nbsp;Matrix&lt;T&gt;::Matrix(unsigned&nbsp;nrows,&nbsp;unsigned&nbsp;ncols)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;data_&nbsp;(nrows)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(nrows&nbsp;==&nbsp;0&nbsp;||&nbsp;ncols&nbsp;==&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;BadSize();<br>
&nbsp;&nbsp;&nbsp;for&nbsp;(unsigned&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nrows;&nbsp;++i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_[i].resize(ncols);<br>
&nbsp;}
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.19"></a>
<div class=FaqTitle><h3>[16.19] Does C++ have arrays whose length can be specified at run-time?</h3></div>
<p>Yes, in the sense that <a href="class-libraries.html#faq-36.1" title="[36.1] What is the &quot;STL&quot;?">the standard library<!--rawtext:[36.1]:rawtext--></a> has a <nobr><tt>std::vector</tt></nobr>
template that provides this behavior.
<p>No, in the sense that built-in array types need to have their length specified
at compile time.
<p>Yes, in the sense that even built-in array types can specify the first index
bounds at run-time.  E.g., comparing with the previous FAQ, if you only need
the first array dimension to vary then you can just ask new for an array of
arrays, rather than an array of pointers to arrays:
<p><div class=CodeBlock>
<tt>
&nbsp;const&nbsp;unsigned&nbsp;ncols&nbsp;=&nbsp;100;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>ncols</tt>&nbsp;=&nbsp;number&nbsp;of&nbsp;columns&nbsp;in&nbsp;the&nbsp;array</em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;Fred&nbsp;{&nbsp;</tt><em>/*...*/</em><tt>&nbsp;};<br>
&nbsp;<br>
&nbsp;void&nbsp;manipulateArray(unsigned&nbsp;nrows)&nbsp;&nbsp;</tt><em>//&nbsp;<tt>nrows</tt>&nbsp;=&nbsp;number&nbsp;of&nbsp;rows&nbsp;in&nbsp;the&nbsp;array</em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;(*matrix)[ncols]&nbsp;=&nbsp;new&nbsp;Fred[nrows][ncols];<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;delete[]&nbsp;matrix;<br>
&nbsp;}
</tt>
</div>
<p>You can't do this if you need anything other than the first dimension of the
array to change at run-time.
<p>But please, don't use arrays unless you have to.  <a href="containers-and-templates.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">Arrays
are evil<!--rawtext:[34.1]:rawtext--></a>.  Use some object of some class if you can.  Use arrays only
when you have to.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.20"></a>
<div class=FaqTitle><h3>[16.20] How can I force objects of my class to always be created via <tt>new</tt> rather than as locals or global/<tt>static</tt> objects?</h3></div>
<p>Use the <a href="ctors.html#faq-10.8" title="[10.8] What is the &quot;Named Constructor Idiom&quot;?">Named Constructor Idiom<!--rawtext:[10.8]:rawtext--></a>.
<p>As usual with the Named Constructor Idiom, the constructors are all <tt>private</tt>
or <tt>protected</tt>, and there are one or more <tt>public</tt> <tt>static</tt> <nobr><tt>create()</tt></nobr> methods
(the so-called &quot;named constructors&quot;), one per constructor.  In this case the
<nobr><tt>create()</tt></nobr> methods allocate the objects via <tt>new</tt>.  Since the constructors
themselves are not <tt>public</tt>, there is no other way to create objects of the
class.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;The&nbsp;<nobr><tt>create()</tt></nobr>&nbsp;methods&nbsp;are&nbsp;the&nbsp;&quot;named&nbsp;constructors&quot;:</em><tt><br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred*&nbsp;create()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;new&nbsp;Fred();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred*&nbsp;create(int&nbsp;i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;new&nbsp;Fred(i);&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred*&nbsp;create(const&nbsp;Fred&amp;&nbsp;fred)&nbsp;{&nbsp;return&nbsp;new&nbsp;Fred(fred);&nbsp;}<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;The&nbsp;constructors&nbsp;themselves&nbsp;are&nbsp;<tt>private</tt>&nbsp;or&nbsp;<tt>protected</tt>:</em><tt><br>
&nbsp;&nbsp;&nbsp;Fred();<br>
&nbsp;&nbsp;&nbsp;Fred(int&nbsp;i);<br>
&nbsp;&nbsp;&nbsp;Fred(const&nbsp;Fred&amp;&nbsp;fred);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};
</tt>
</div>
<p>Now the only way to create <tt>Fred</tt> objects is via <nobr><tt>Fred::create()</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;Fred::create(5);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;delete&nbsp;p;<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>Make sure your constructors are in the <tt>protected</tt> section if you expect
<tt>Fred</tt> to have derived classes.
<p>Note also that you can make another class <tt>Wilma</tt> a <a href="friends.html" title="[14] Friends"><tt>friend</tt><!--rawtext:[14]:rawtext--></a> of <tt>Fred</tt> if you want to allow a <tt>Wilma</tt> to have a member object
of class <tt>Fred</tt>, but of course this is a softening of the original goal, namely
to force <tt>Fred</tt> objects to be allocated via <tt>new</tt>.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.21"></a>
<div class=FaqTitle><h3>[16.21] How do I do simple reference counting?</h3></div>
<p>If all you want is the ability to pass around a bunch of pointers to the same
object, with the feature that the object will automagically get <tt>delete</tt>d when
the last pointer to it disappears, you can use something like the following
&quot;smart pointer&quot; class:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;Fred.h</em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;FredPtr;<br>
&nbsp;<br>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred()&nbsp;:&nbsp;count_(0)&nbsp;</tt><em>/*...*/</em><tt>&nbsp;{&nbsp;}&nbsp;&nbsp;</tt><em>//&nbsp;All&nbsp;ctors&nbsp;set&nbsp;<tt>count_</tt>&nbsp;to&nbsp;0&nbsp;!</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;FredPtr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<a href="friends.html" title="[14] Friends">A&nbsp;friend&nbsp;class<!--rawtext:[14]:rawtext--></a></em><tt><br>
&nbsp;&nbsp;&nbsp;unsigned&nbsp;count_;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>count_</tt>&nbsp;must&nbsp;be&nbsp;initialized&nbsp;to&nbsp;0&nbsp;by&nbsp;all&nbsp;constructors</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>count_</tt>&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;<tt>FredPtr</tt>&nbsp;objects&nbsp;that&nbsp;point&nbsp;at&nbsp;<tt>this</tt></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;class&nbsp;FredPtr&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred*&nbsp;operator-&gt;&nbsp;()&nbsp;{&nbsp;return&nbsp;p_;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;Fred&amp;&nbsp;operator*&nbsp;()&nbsp;&nbsp;{&nbsp;return&nbsp;*p_;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;FredPtr(Fred*&nbsp;p)&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;p_(p)&nbsp;{&nbsp;++p_-&gt;count_;&nbsp;}&nbsp;&nbsp;</tt><em>//&nbsp;<tt>p</tt>&nbsp;must&nbsp;not&nbsp;be&nbsp;<tt>NULL</tt></em><tt><br>
&nbsp;&nbsp;~FredPtr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;if&nbsp;(--p_-&gt;count_&nbsp;==&nbsp;0)&nbsp;delete&nbsp;p_;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;FredPtr(const&nbsp;FredPtr&amp;&nbsp;p)&nbsp;:&nbsp;p_(p.p_)&nbsp;{&nbsp;++p_-&gt;count_;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;FredPtr&amp;&nbsp;operator=&nbsp;(const&nbsp;FredPtr&amp;&nbsp;p)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;</tt><em>//&nbsp;DO&nbsp;NOT&nbsp;CHANGE&nbsp;THE&nbsp;ORDER&nbsp;OF&nbsp;THESE&nbsp;STATEMENTS!</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;(This&nbsp;order&nbsp;properly&nbsp;handles&nbsp;<a href="assignment-operators.html#faq-12.1" title="[12.1] What is &quot;self assignment&quot;?">self-assignment<!--rawtext:[12.1]:rawtext--></a>)</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++p.p_-&gt;count_;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(--p_-&gt;count_&nbsp;==&nbsp;0)&nbsp;delete&nbsp;p_;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p_&nbsp;=&nbsp;p.p_;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;Fred*&nbsp;p_;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>p_</tt>&nbsp;is&nbsp;never&nbsp;<tt>NULL</tt></em><tt><br>
&nbsp;};
</tt>
</div>
<p>Naturally you can use nested classes to rename <tt>FredPtr</tt> to
<nobr><tt>Fred::Ptr</tt></nobr>.
<p>Note that you can soften the &quot;never <tt>NULL</tt>&quot; rule above with a little more
checking in the constructor, copy constructor, assignment operator, and
destructor.  If you do that, you might as well put a <nobr><tt>p_ != NULL</tt></nobr> check
into the &quot;<nobr><tt>*</tt></nobr>&quot; and &quot;<nobr><tt>-&gt;</tt></nobr>&quot; operators (at least as an <nobr><tt>assert()</tt></nobr>).  I
would recommend against an <nobr><tt>operator Fred*()</tt></nobr> method, since that would
let people accidentally get at the <nobr><tt>Fred*</tt></nobr>.
<p>One of the implicit constraints on <tt>FredPtr</tt> is that it must only point
to <tt>Fred</tt> objects which have been allocated via <tt>new</tt>.  If you want to be
really safe, you can enforce this constraint by making all of <tt>Fred</tt>'s
constructors <tt>private</tt>, and for each constructor have a <tt>public</tt> (<tt>static</tt>)
<nobr><tt>create()</tt></nobr> method which allocates the <tt>Fred</tt> object via <tt>new</tt> and returns a
<tt>FredPtr</tt> (not a <nobr><tt>Fred*</tt></nobr>).  That way the <em>only</em> way anyone could
create a <tt>Fred</tt> object would be to get a <tt>FredPtr</tt> (&quot;<nobr><tt>Fred* p = new
Fred()</tt></nobr>&quot; would be replaced by &quot;<nobr><tt>FredPtr p = Fred::create()</tt></nobr>&quot;).  Thus
no one could accidentally subvert the reference counted mechanism.
<p>For example, if <tt>Fred</tt> had a <nobr><tt>Fred::Fred()</tt></nobr> and a <nobr><tt>Fred::Fred(int i,
int j)</tt></nobr>, the changes to <tt>class</tt> <tt>Fred</tt> would be:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;static&nbsp;FredPtr&nbsp;create();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Defined&nbsp;below&nbsp;<nobr><tt>class&nbsp;FredPtr&nbsp;{</tt>...<tt>};</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;static&nbsp;FredPtr&nbsp;create(int&nbsp;i,&nbsp;int&nbsp;j);&nbsp;&nbsp;</tt><em>//&nbsp;Defined&nbsp;below&nbsp;<nobr><tt>class&nbsp;FredPtr&nbsp;{</tt>...<tt>};</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;Fred();<br>
&nbsp;&nbsp;&nbsp;Fred(int&nbsp;i,&nbsp;int&nbsp;j);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;class&nbsp;FredPtr&nbsp;{&nbsp;</tt><em>/*&nbsp;...&nbsp;*/</em><tt>&nbsp;};<br>
&nbsp;<br>
&nbsp;inline&nbsp;FredPtr&nbsp;Fred::create()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;new&nbsp;Fred();&nbsp;}<br>
&nbsp;inline&nbsp;FredPtr&nbsp;Fred::create(int&nbsp;i,&nbsp;int&nbsp;j)&nbsp;{&nbsp;return&nbsp;new&nbsp;Fred(i,j);&nbsp;}
</tt>
</div>
<p>The end result is that you now have a way to use simple reference counting to
provide &quot;pointer semantics&quot; for a given object.  Users of your <tt>Fred</tt> <tt>class</tt>
explicitly use <tt>FredPtr</tt> objects, which act more or less like <nobr><tt>Fred*</tt></nobr>
pointers.  The benefit is that users can make as many copies of their
<tt>FredPtr</tt> &quot;smart pointer&quot; objects, and the pointed-to <tt>Fred</tt> object will
automagically get <tt>delete</tt>d when the last such <tt>FredPtr</tt> object vanishes.
<p>If you'd rather give your users &quot;reference semantics&quot; rather than &quot;pointer
semantics,&quot; you can use <a href="freestore-mgmt.html#faq-16.22" title="[16.22] How do I provide reference counting with copy-on-write semantics?">reference counting to provide
&quot;copy on write&quot;<!--rawtext:[16.22]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.22"></a>
<div class=FaqTitle><h3>[16.22] How do I provide reference counting with copy-on-write semantics?</h3></div>
<p>Reference counting can be done with either pointer semantics or reference
semantics.  The <a href="freestore-mgmt.html#faq-16.21" title="[16.21] How do I do simple reference counting?">previous FAQ<!--rawtext:[16.21]:rawtext--></a> shows how to do
reference counting with pointer semantics.  This FAQ shows how to do reference
counting with reference semantics.
<p>The basic idea is to allow users to think they're copying your <tt>Fred</tt> objects,
but in reality the underlying implementation doesn't actually do any copying
unless and until some user actually tries to modify the underlying <tt>Fred</tt>
object.
<p>Class <nobr><tt>Fred::Data</tt></nobr> houses all the data that would normally go into the
<tt>Fred</tt> <tt>class</tt>.  <nobr><tt>Fred::Data</tt></nobr> also has an extra data member,
<tt>count_</tt>, to manage the reference counting.  Class <tt>Fred</tt> ends up being a
&quot;smart reference&quot; that (internally) points to a <nobr><tt>Fred::Data</tt></nobr>.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Fred();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">A&nbsp;default&nbsp;constructor<!--rawtext:[10.4]:rawtext--></a></em><tt><br>
&nbsp;&nbsp;&nbsp;Fred(int&nbsp;i,&nbsp;int&nbsp;j);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;A&nbsp;normal&nbsp;constructor</em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Fred(const&nbsp;Fred&amp;&nbsp;f);<br>
&nbsp;&nbsp;&nbsp;Fred&amp;&nbsp;operator=&nbsp;(const&nbsp;Fred&amp;&nbsp;f);<br>
&nbsp;&nbsp;~Fred();<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;void&nbsp;sampleInspectorMethod()&nbsp;const;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;changes&nbsp;to&nbsp;<tt>this</tt>&nbsp;object</em><tt><br>
&nbsp;&nbsp;&nbsp;void&nbsp;sampleMutatorMethod();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Change&nbsp;<tt>this</tt>&nbsp;object</em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;class&nbsp;Data&nbsp;{<br>
&nbsp;&nbsp;&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data(int&nbsp;i,&nbsp;int&nbsp;j);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data(const&nbsp;Data&amp;&nbsp;d);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Since&nbsp;only&nbsp;<tt>Fred</tt>&nbsp;can&nbsp;access&nbsp;a&nbsp;<nobr><tt>Fred::Data</tt></nobr>&nbsp;object,</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;you&nbsp;can&nbsp;make&nbsp;<nobr><tt>Fred::Data</tt></nobr>'s&nbsp;data&nbsp;<tt>public</tt>&nbsp;if&nbsp;you&nbsp;want.</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;But&nbsp;if&nbsp;that&nbsp;makes&nbsp;you&nbsp;uncomfortable,&nbsp;make&nbsp;the&nbsp;data&nbsp;<tt>private</tt></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;and&nbsp;make&nbsp;<tt>Fred</tt>&nbsp;a&nbsp;<a href="friends.html" title="[14] Friends">friend&nbsp;class<!--rawtext:[14]:rawtext--></a>&nbsp;via&nbsp;<nobr><tt>friend&nbsp;Fred;</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>...data&nbsp;goes&nbsp;here...</em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;count_;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>count_</tt>&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;<tt>Fred</tt>&nbsp;objects&nbsp;that&nbsp;point&nbsp;at&nbsp;<tt>this</tt></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>count_</tt>&nbsp;must&nbsp;be&nbsp;initialized&nbsp;to&nbsp;1&nbsp;by&nbsp;all&nbsp;constructors</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;(it&nbsp;starts&nbsp;as&nbsp;1&nbsp;since&nbsp;it&nbsp;is&nbsp;pointed&nbsp;to&nbsp;by&nbsp;the&nbsp;<tt>Fred</tt>&nbsp;object&nbsp;that&nbsp;created&nbsp;it)</em><tt><br>
&nbsp;&nbsp;&nbsp;};<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Data*&nbsp;data_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;Fred::Data::Data()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;count_(1)&nbsp;</tt><em>/*init&nbsp;other&nbsp;data*/</em><tt>&nbsp;{&nbsp;}<br>
&nbsp;Fred::Data::Data(int&nbsp;i,&nbsp;int&nbsp;j)&nbsp;&nbsp;:&nbsp;count_(1)&nbsp;</tt><em>/*init&nbsp;other&nbsp;data*/</em><tt>&nbsp;{&nbsp;}<br>
&nbsp;Fred::Data::Data(const&nbsp;Data&amp;&nbsp;d)&nbsp;:&nbsp;count_(1)&nbsp;</tt><em>/*init&nbsp;other&nbsp;data*/</em><tt>&nbsp;{&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred::Fred()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;data_(new&nbsp;Data())&nbsp;{&nbsp;}<br>
&nbsp;Fred::Fred(int&nbsp;i,&nbsp;int&nbsp;j)&nbsp;:&nbsp;data_(new&nbsp;Data(i,&nbsp;j))&nbsp;{&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred::Fred(const&nbsp;Fred&amp;&nbsp;f)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;data_(f.data_)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;++&nbsp;data_-&gt;count_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred&amp;&nbsp;Fred::operator=&nbsp;(const&nbsp;Fred&amp;&nbsp;f)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;DO&nbsp;NOT&nbsp;CHANGE&nbsp;THE&nbsp;ORDER&nbsp;OF&nbsp;THESE&nbsp;STATEMENTS!</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;(This&nbsp;order&nbsp;properly&nbsp;handles&nbsp;<a href="assignment-operators.html#faq-12.1" title="[12.1] What is &quot;self assignment&quot;?">self-assignment<!--rawtext:[12.1]:rawtext--></a>)</em><tt><br>
&nbsp;&nbsp;&nbsp;++&nbsp;f.data_-&gt;count_;<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(--data_-&gt;count_&nbsp;==&nbsp;0)&nbsp;delete&nbsp;data_;<br>
&nbsp;&nbsp;&nbsp;data_&nbsp;=&nbsp;f.data_;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred::~Fred()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(--data_-&gt;count_&nbsp;==&nbsp;0)&nbsp;delete&nbsp;data_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;Fred::sampleInspectorMethod()&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;This&nbsp;method&nbsp;promises&nbsp;(&quot;<tt>const</tt>&quot;)&nbsp;not&nbsp;to&nbsp;change&nbsp;anything&nbsp;in&nbsp;<nobr><tt>*data_</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Other&nbsp;than&nbsp;that,&nbsp;any&nbsp;data&nbsp;access&nbsp;would&nbsp;simply&nbsp;use&nbsp;&quot;<nobr><tt>data_-&gt;</tt></nobr>...&quot;</em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;Fred::sampleMutatorMethod()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;This&nbsp;method&nbsp;might&nbsp;need&nbsp;to&nbsp;change&nbsp;things&nbsp;in&nbsp;<nobr><tt>*data_</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Thus&nbsp;it&nbsp;first&nbsp;checks&nbsp;if&nbsp;<tt>this</tt>&nbsp;is&nbsp;the&nbsp;only&nbsp;pointer&nbsp;to&nbsp;<nobr><tt>*data_</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;if&nbsp;(data_-&gt;count_&nbsp;&gt;&nbsp;1)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data*&nbsp;d&nbsp;=&nbsp;new&nbsp;Data(*data_);&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Invoke&nbsp;<nobr><tt>Fred::Data</tt></nobr>'s&nbsp;copy&nbsp;ctor</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;data_-&gt;count_;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_&nbsp;=&nbsp;d;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;assert(data_-&gt;count_&nbsp;==&nbsp;1);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Now&nbsp;the&nbsp;method&nbsp;proceeds&nbsp;to&nbsp;access&nbsp;&quot;<nobr><tt>data_-&gt;</tt></nobr>...&quot;&nbsp;as&nbsp;normal</em><tt><br>
&nbsp;}
</tt>
</div>
<p>If it is fairly common to call <tt>Fred</tt>'s <a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default
constructor<!--rawtext:[10.4]:rawtext--></a>, you can avoid all those <tt>new</tt> calls by sharing
a common <nobr><tt>Fred::Data</tt></nobr> object for all <tt>Fred</tt>s that are constructed via
<nobr><tt>Fred::Fred()</tt></nobr>.  To avoid <tt>static</tt> initialization order problems, this
shared <nobr><tt>Fred::Data</tt></nobr> object is created &quot;on first use&quot; inside a function.
Here are the changes that would be made to the above code (note that the shared
<nobr><tt>Fred::Data</tt></nobr> object's destructor is never invoked; if that is a problem,
either hope you don't have any <tt>static</tt> initialization order problems, or drop
back to the approach described above):
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;static&nbsp;Data*&nbsp;defaultData();<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;Fred::Fred()<br>
&nbsp;:&nbsp;data_(defaultData())<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;++&nbsp;data_-&gt;count_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred::Data*&nbsp;Fred::defaultData()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Data*&nbsp;p&nbsp;=&nbsp;NULL;<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(p&nbsp;==&nbsp;NULL)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;new&nbsp;Data();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;p-&gt;count_;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Make&nbsp;sure&nbsp;it&nbsp;never&nbsp;goes&nbsp;to&nbsp;zero</em><tt><br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;return&nbsp;p;<br>
&nbsp;}
</tt>
</div>
<p>Note: You can also provide <a href="freestore-mgmt.html#faq-16.23" title="[16.23] How do I provide reference counting with copy-on-write semantics for a hierarchy of classes?">reference
counting for a hierarchy of classes<!--rawtext:[16.23]:rawtext--></a> if your <tt>Fred</tt> class would normally
have been a base class.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.23"></a>
<div class=FaqTitle><h3>[16.23] How do I provide reference counting with copy-on-write semantics for a hierarchy of classes? <span class=Updated>&nbsp;Updated!&nbsp;</span></h3></div>
<small><em>[Recently fixed a subtle bug in the code thanks to <a href="mailto:jmegq@mac.com" title="jmegq@mac.com">James Megquier</a> (in 5/03).  <a href="virtual-functions.html#faq-20.6" title="[20.6] What is a &quot;virtual constructor&quot;?">Click here to go to the next FAQ in the &quot;chain&quot; of recent changes<!--rawtext:[20.6]:rawtext--></a>.]</em></small>
<p>The <a href="freestore-mgmt.html#faq-16.22" title="[16.22] How do I provide reference counting with copy-on-write semantics?">previous FAQ<!--rawtext:[16.22]:rawtext--></a> presented a reference counting
scheme that provided users with reference semantics, but did so for a single
class rather than for a hierarchy of classes.  This FAQ extends the previous
technique to allow for a hierarchy of classes.  The basic difference is that
<nobr><tt>Fred::Data</tt></nobr> is now the root of a hierarchy of classes, which probably
cause it to have some <a href="virtual-functions.html" title="[20] Inheritance -- virtual functions"><tt>virtual</tt><!--rawtext:[20]:rawtext--></a> functions.  Note
that class <tt>Fred</tt> itself will still not have any <tt>virtual</tt> functions.
<p>The <a href="virtual-functions.html#faq-20.6" title="[20.6] What is a &quot;virtual constructor&quot;?">Virtual Constructor Idiom<!--rawtext:[20.6]:rawtext--></a> is used to make
copies of the <nobr><tt>Fred::Data</tt></nobr> objects.  To select which derived class to
create, the sample code below uses the <a href="ctors.html#faq-10.8" title="[10.8] What is the &quot;Named Constructor Idiom&quot;?">Named Constructor
Idiom<!--rawtext:[10.8]:rawtext--></a>, but other techniques are possible (a
<tt>switch</tt> statement in the constructor, etc).  The sample code assumes two
derived classes: <tt>Der1</tt> and <tt>Der2</tt>.  Methods in the derived classes are unaware
of the reference counting.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&nbsp;create1(const&nbsp;std::string&amp;&nbsp;s,&nbsp;int&nbsp;i);<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&nbsp;create2(float&nbsp;x,&nbsp;float&nbsp;y);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Fred(const&nbsp;Fred&amp;&nbsp;f);<br>
&nbsp;&nbsp;&nbsp;Fred&amp;&nbsp;operator=&nbsp;(const&nbsp;Fred&amp;&nbsp;f);<br>
&nbsp;&nbsp;~Fred();<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;void&nbsp;sampleInspectorMethod()&nbsp;const;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;changes&nbsp;to&nbsp;<tt>this</tt>&nbsp;object</em><tt><br>
&nbsp;&nbsp;&nbsp;void&nbsp;sampleMutatorMethod();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Change&nbsp;<tt>this</tt>&nbsp;object</em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;class&nbsp;Data&nbsp;{<br>
&nbsp;&nbsp;&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data()&nbsp;:&nbsp;count_(1)&nbsp;{&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data(const&nbsp;Data&amp;&nbsp;d)&nbsp;:&nbsp;count_(1)&nbsp;{&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Do&nbsp;NOT&nbsp;copy&nbsp;the&nbsp;'count_'&nbsp;member!</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data&amp;&nbsp;operator=&nbsp;(const&nbsp;Data&amp;)&nbsp;{&nbsp;return&nbsp;*this;&nbsp;}&nbsp;&nbsp;</tt><em>//&nbsp;Do&nbsp;NOT&nbsp;copy&nbsp;the&nbsp;'count_'&nbsp;member!</em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;~Data()&nbsp;{&nbsp;assert(count_&nbsp;==&nbsp;0);&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<a href="virtual-functions.html#faq-20.5" title="[20.5] When should my destructor be virtual?">A&nbsp;virtual&nbsp;destructor<!--rawtext:[20.5]:rawtext--></a></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;Data*&nbsp;clone()&nbsp;const&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<a href="virtual-functions.html#faq-20.6" title="[20.6] What is a &quot;virtual constructor&quot;?">A&nbsp;virtual&nbsp;constructor<!--rawtext:[20.6]:rawtext--></a></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;sampleInspectorMethod()&nbsp;const&nbsp;=&nbsp;0;&nbsp;&nbsp;</tt><em>//&nbsp;<a href="abcs.html#faq-22.4" title="[22.4] What is a &quot;pure virtual&quot; member function?">A&nbsp;pure&nbsp;virtual&nbsp;function<!--rawtext:[22.4]:rawtext--></a></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;sampleMutatorMethod()&nbsp;=&nbsp;0;<br>
&nbsp;&nbsp;&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;count_;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>count_</tt>&nbsp;doesn't&nbsp;need&nbsp;to&nbsp;be&nbsp;<tt>protected</tt></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;friend&nbsp;Fred;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Allow&nbsp;<tt>Fred</tt>&nbsp;to&nbsp;access&nbsp;<tt>count_</tt></em><tt><br>
&nbsp;&nbsp;&nbsp;};<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;class&nbsp;Der1&nbsp;:&nbsp;public&nbsp;Data&nbsp;{<br>
&nbsp;&nbsp;&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Der1(const&nbsp;std::string&amp;&nbsp;s,&nbsp;int&nbsp;i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;sampleInspectorMethod()&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;sampleMutatorMethod();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;Data*&nbsp;clone()&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;};<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;class&nbsp;Der2&nbsp;:&nbsp;public&nbsp;Data&nbsp;{<br>
&nbsp;&nbsp;&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Der2(float&nbsp;x,&nbsp;float&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;sampleInspectorMethod()&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;void&nbsp;sampleMutatorMethod();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;virtual&nbsp;Data*&nbsp;clone()&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;};<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Fred(Data*&nbsp;data);<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Creates&nbsp;a&nbsp;<tt>Fred</tt>&nbsp;smart-reference&nbsp;that&nbsp;owns&nbsp;<nobr><tt>*data</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;It&nbsp;is&nbsp;<tt>private</tt>&nbsp;to&nbsp;force&nbsp;users&nbsp;to&nbsp;use&nbsp;a&nbsp;<nobr><tt>createXXX()</tt></nobr>&nbsp;method</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Requirement:&nbsp;<tt>data</tt>&nbsp;must&nbsp;not&nbsp;be&nbsp;<tt>NULL</tt></em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Data*&nbsp;data_;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Invariant:&nbsp;<tt>data_</tt>&nbsp;is&nbsp;never&nbsp;<tt>NULL</tt></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;Fred::Fred(Data*&nbsp;data)&nbsp;:&nbsp;data_(data)&nbsp;&nbsp;{&nbsp;assert(data&nbsp;!=&nbsp;NULL);&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred&nbsp;Fred::create1(const&nbsp;std::string&amp;&nbsp;s,&nbsp;int&nbsp;i)&nbsp;{&nbsp;return&nbsp;Fred(new&nbsp;Der1(s,&nbsp;i));&nbsp;}<br>
&nbsp;Fred&nbsp;Fred::create2(float&nbsp;x,&nbsp;float&nbsp;y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;Fred(new&nbsp;Der2(x,&nbsp;y));&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred::Data*&nbsp;Fred::Der1::clone()&nbsp;const&nbsp;{&nbsp;return&nbsp;new&nbsp;Der1(*this);&nbsp;}<br>
&nbsp;Fred::Data*&nbsp;Fred::Der2::clone()&nbsp;const&nbsp;{&nbsp;return&nbsp;new&nbsp;Der2(*this);&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred::Fred(const&nbsp;Fred&amp;&nbsp;f)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;data_(f.data_)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;++&nbsp;data_-&gt;count_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred&amp;&nbsp;Fred::operator=&nbsp;(const&nbsp;Fred&amp;&nbsp;f)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;DO&nbsp;NOT&nbsp;CHANGE&nbsp;THE&nbsp;ORDER&nbsp;OF&nbsp;THESE&nbsp;STATEMENTS!</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;(This&nbsp;order&nbsp;properly&nbsp;handles&nbsp;<a href="assignment-operators.html#faq-12.1" title="[12.1] What is &quot;self assignment&quot;?">self-assignment<!--rawtext:[12.1]:rawtext--></a>)</em><tt><br>
&nbsp;&nbsp;&nbsp;++&nbsp;f.data_-&gt;count_;<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(--data_-&gt;count_&nbsp;==&nbsp;0)&nbsp;delete&nbsp;data_;<br>
&nbsp;&nbsp;&nbsp;data_&nbsp;=&nbsp;f.data_;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Fred::~Fred()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(--data_-&gt;count_&nbsp;==&nbsp;0)&nbsp;delete&nbsp;data_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;Fred::sampleInspectorMethod()&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;This&nbsp;method&nbsp;promises&nbsp;(&quot;<tt>const</tt>&quot;)&nbsp;not&nbsp;to&nbsp;change&nbsp;anything&nbsp;in&nbsp;<nobr><tt>*data_</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Therefore&nbsp;we&nbsp;simply&nbsp;&quot;pass&nbsp;the&nbsp;method&nbsp;through&quot;&nbsp;to&nbsp;<nobr><tt>*data_</tt></nobr>:</em><tt><br>
&nbsp;&nbsp;&nbsp;data_-&gt;sampleInspectorMethod();<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;Fred::sampleMutatorMethod()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;This&nbsp;method&nbsp;might&nbsp;need&nbsp;to&nbsp;change&nbsp;things&nbsp;in&nbsp;<nobr><tt>*data_</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Thus&nbsp;it&nbsp;first&nbsp;checks&nbsp;if&nbsp;<tt>this</tt>&nbsp;is&nbsp;the&nbsp;only&nbsp;pointer&nbsp;to&nbsp;<nobr><tt>*data_</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;if&nbsp;(data_-&gt;count_&nbsp;&gt;&nbsp;1)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Data*&nbsp;d&nbsp;=&nbsp;data_-&gt;clone();&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<a href="virtual-functions.html#faq-20.6" title="[20.6] What is a &quot;virtual constructor&quot;?">The&nbsp;Virtual&nbsp;Constructor&nbsp;Idiom<!--rawtext:[20.6]:rawtext--></a></em><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;data_-&gt;count_;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_&nbsp;=&nbsp;d;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;assert(data_-&gt;count_&nbsp;==&nbsp;1);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Now&nbsp;we&nbsp;&quot;pass&nbsp;the&nbsp;method&nbsp;through&quot;&nbsp;to&nbsp;<nobr><tt>*data_</tt></nobr>:</em><tt><br>
&nbsp;&nbsp;&nbsp;data_-&gt;sampleMutatorMethod();<br>
&nbsp;}
</tt>
</div>
<p>Naturally the constructors and <tt>sampleXXX</tt> methods for <nobr><tt>Fred::Der1</tt></nobr>
and <nobr><tt>Fred::Der2</tt></nobr> will need to be implemented in whatever way is
appropriate.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.24"></a>
<div class=FaqTitle><h3>[16.24] Can you absolutely <em>prevent</em> people from subverting the reference counting mechanism, and if so, <em>should</em> you?</h3></div>
<p>No, and (normally) no.
<p>There are two basic approaches to subverting the reference counting mechanism:
<ol>
<li>The scheme could be subverted if someone got a <nobr><tt>Fred*</tt></nobr>
(rather than being forced to use a <tt>FredPtr</tt>).  Someone could get a
<nobr><tt>Fred*</tt></nobr> if class <tt>FredPtr</tt> has an <nobr><tt>operator*()</tt></nobr> that returns
a <nobr><tt>Fred&amp;</tt></nobr>: <nobr><tt>FredPtr p = Fred::create(); Fred* p2 = &amp;*p;</tt></nobr>.  Yes
it's bizarre and unexpected, but it could happen.  This hole could be closed
in two ways: overload <nobr><tt>Fred::operator&amp;()</tt></nobr> so it returns a
<tt>FredPtr</tt>, or change the return type of <nobr><tt>FredPtr::operator*()</tt></nobr> so
it returns a <tt>FredRef</tt> (<tt>FredRef</tt> would be a class that simulates
a reference; it would need to have all the methods that <tt>Fred</tt> has, and
it would need to forward all those method calls to the underlying <tt>Fred</tt>
object; there might be a performance penalty for this second choice depending
on how good the compiler is at inlining methods).  Another way to fix this is
to eliminate <nobr><tt>FredPtr::operator*()</tt></nobr> &#151; and lose the corresponding
ability to get and use a <nobr><tt>Fred&amp;</tt></nobr>.  But even if you did all this, someone
could still generate a <nobr><tt>Fred*</tt></nobr> by explicitly calling
<nobr><tt>operator-&gt;()</tt></nobr>: <nobr><tt>FredPtr p = Fred::create(); Fred* p2 =
p.operator-&gt;();</tt></nobr>.</li>
<li>The scheme could be subverted if someone had a leak and/or dangling
pointer to a <tt>FredPtr</tt> Basically what we're saying here is that
<tt>Fred</tt> is now safe, but we somehow want to prevent people from doing
stupid things with <tt>FredPtr</tt> objects.  (And if we could solve that via
<tt>FredPtrPtr</tt> objects, we'd have the same problem again with them).  One
hole here is if someone created a <tt>FredPtr</tt> using <tt>new</tt>, then
allowed the <tt>FredPtr</tt> to leak (worst case this is a leak, which is bad
but is <em>usually</em> a little better than a dangling pointer).  This hole
could be plugged by declaring <nobr><tt>FredPtr::operator new()</tt></nobr> as <tt>private</tt>,
thus preventing someone from saying <nobr><tt>new FredPtr()</tt></nobr>.  Another hole here
is if someone creates a local <tt>FredPtr</tt> object, then takes the address
of that <tt>FredPtr</tt> and passed around the <nobr><tt>FredPtr*</tt></nobr>.  If that
<nobr><tt>FredPtr*</tt></nobr> lived longer than the <tt>FredPtr</tt>, you could have a
dangling pointer &#151; shudder.  This hole could be plugged by preventing people
from taking the address of a <tt>FredPtr</tt> (by overloading
<nobr><tt>FredPtr::operator&amp;()</tt></nobr> as <tt>private</tt>), with the corresponding loss of
functionality.  But even if you did all that, they could still create a
<nobr><tt>FredPtr&amp;</tt></nobr> which is almost as dangerous as a <nobr><tt>FredPtr*</tt></nobr>, simply by
doing this: <nobr><tt>FredPtr p; </tt>...<tt> FredPtr&amp; q = p;</tt></nobr> (or by passing the
<nobr><tt>FredPtr&amp;</tt></nobr> to someone else).</li>
</ol>
<p>And even if we closed <em>all</em> those holes, C++ has those wonderful pieces
of syntax called pointer casts.  Using a pointer cast or two, a sufficiently
motivated programmer can normally create a hole that's big enough to drive a
proverbial truck through.  (By the way, <a href="coding-standards.html#faq-27.10" title="[27.10] Why do people worry so much about pointer casts and/or reference casts?">pointer casts are
evil<!--rawtext:[27.10]:rawtext--></a>.)
<p>So the lessons here seems to be: (a) you can't prevent espionage no matter how
hard you try, and (b) you can easily prevent mistakes.
<p>So I recommend settling for the &quot;low hanging fruit&quot;: use the easy-to-build and
easy-to-use mechanisms that prevent mistakes, and don't bother trying to
prevent espionage.  You won't succeed, and even if you do, it'll (probably)
cost you more than it's worth.
<p>So if we can't use the C++ language itself to prevent espionage, are there
other ways to do it?  Yes.  I personally use old fashioned code reviews for
that.  And since the espionage techniques usually involve some bizarre syntax
and/or use of pointer-casts and unions, you can use a tool to point out most
of the &quot;hot spots.&quot;
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.25"></a>
<div class=FaqTitle><h3>[16.25] Can I use a garbage collector in C++?</h3></div>
<p>Yes.
<p>Compared with the &quot;smart pointer&quot; techniques (see <a href="freestore-mgmt.html#faq-16.21" title="[16.21] How do I do simple reference counting?">[16.21]</a>,
the two kinds of garbage collector techniques (see
<a href="freestore-mgmt.html#faq-16.26" title="[16.26] What are the two kinds of garbage collectors for C++?">[16.26]</a>) are:
<ul>
<li>less portable</li>
<li>usually more efficient (especially when the average object size is
small or in multithreaded environments)</li>
<li>able to handle &quot;cycles&quot; in the data (reference counting techniques
normally &quot;leak&quot; if the data structures can form a cycle)</li>
<li>sometimes leak other objects (since the garbage collectors are
necessarily conservative, they sometimes see a random bit pattern that appears
to be a pointer into an allocation, especially if the allocation is large;
this can allow the allocation to leak)</li>
<li>work better with existing libraries (since smart pointers need to
be used explicitly, they may be hard to integrate with existing
libraries)</li>
</ul>
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.26"></a>
<div class=FaqTitle><h3>[16.26] What are the two kinds of garbage collectors for C++?</h3></div>
<p>In general, there seem to be two flavors of garbage collectors for C++:
<ol>
<li>
<p><em>Conservative garbage collectors.</em> These know little or nothing about
the layout of the stack or of C++ objects, and simply look for bit patterns
that appear to be pointers.  In practice they seem to work with both C and C++
code, particularly when the average object size is small.  Here are some
examples, in alphabetical order:
<ul>
<li><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc" title="www.hpl.hp.com/personal/Hans_Boehm/gc" target='_blank'>Boehm-Demers-Weiser collector</a></li>
<li><a href="http://www.geodesic.com/solutions/greatcircle.html" title="www.geodesic.com/solutions/greatcircle.html" target='_blank'>Geodesic
Systems collector</a></li>
</ul>
</li>
<li>
<p><em>Hybrid garbage collectors.</em> These usually scan the stack
conservatively, but require the programmer to supply layout information for
heap objects.  This requires more work on the programmer's part, but may
result in improved performance.  Here are some examples, in alphabetical
order:
<ul>
<li><a href="http://citeseer.nj.nec.com/attardi96memory.html" title="citeseer.nj.nec.com/attardi96memory.html" target='_blank'>Attardi and Flagella's CMM</a></li>
<li><a href="ftp://gatekeeper.dec.com/pub/DEC/WRL/research-reports/WRL-TR-88.2.pdf" title="gatekeeper.dec.com/pub/DEC/WRL/research-reports/WRL-TR-88.2.pdf" target='_blank'>Bartlett's mostly copying collector</a></li>
</ul>
</li>
</ol>
<p>Since garbage collectors for C++ are normally conservative, they can sometimes
leak if a bit pattern &quot;looks like&quot; it might be a pointer to an otherwise
unused block.  Also they sometimes get confused when pointers to a block
actually point outside the block's extent (which is illegal, but some
programmers simply <em>must</em> push the envelope; sigh) and (rarely) when a
pointer is hidden by a compiler optimization.  In practice these problems are
not usually serious, however providing the collector with hints about the
layout of the objects can sometimes ameliorate these issues.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-16.27"></a>
<div class=FaqTitle><h3>[16.27] Where can I get more info on garbage collectors for C++?</h3></div>
<p>For more information, see <a href="http://www.iecc.com/gclist/GC-faq.html" title="www.iecc.com/gclist/GC-faq.html" target='_blank'>the
Garbage Collector FAQ</a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [16] Freestore management">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [16] Freestore management">Bottom</a> |&nbsp;<a href="input-output.html" title="[15] Input/output via &lt;iostream&gt; and &lt;cstdio&gt;">Previous&nbsp;section</a> |&nbsp;<a href="exceptions.html" title="[17] Exceptions and error handling">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="bottom"></a>
<a href="mailto:cline@parashift.com" title="cline@parashift.com"><img src="mbox.gif" height=26 width=89 alt="E-Mail">&nbsp;E-mail the author</a><br>
[&nbsp;<a href="index.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>
|&nbsp;<a href="index.html#table-of-contents" title="Table of contents">Table&nbsp;of&nbsp;contents</a>
|&nbsp;<a href="subject-index.html" title="Subject index; 3706 links to 2361 topics">Subject&nbsp;index</a>
|&nbsp;<a href="copy-permissions.html#faq-1.1" title="[1.1] Author">About&nbsp;the&nbsp;author</a>
|&nbsp;<a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">&copy;</a>
|&nbsp;<a href="on-line-availability.html#faq-2.2" title="[2.2] How can I get a copy of all the HTML files of C++ FAQ Lite so I can read them Off-Line?">Download&nbsp;your&nbsp;own&nbsp;copy</a>&nbsp;]<br>
<small>Revised May 2, 2003</small>
</body>
</html>
