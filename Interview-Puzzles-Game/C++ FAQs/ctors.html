<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
	"http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<title>[10] Constructors, C++ FAQ Lite</title>
<meta name="FILENAME" content="ctors.html">
<meta name="ABSTRACT" content="[10] Constructors, C++ FAQ Lite">
<meta name="OWNER"    content="cline@parashift.com">
<meta name="AUTHOR"   content="Marshall Cline, cline@parashift.com">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rev=made href="mailto:cline@parashift.com">
<style type='text/css'>
  <!--
  body       { font-family: arial; color: black; background: white }
  .CodeBlock { color: black; background-color: #dfdfdf; margin-left: 30px; margin-right: 30px; padding: 5pt }
  .FaqTitle  { color: black; background-color: gold }
  .Updated   { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #ffff00; border: solid #e0e000 1px; }
  .New       { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #00ff00; border: solid #00d000 1px; }
  ul         { margin-bottom: 1px; margin-top: 1px }
  ol         { margin-bottom: 1px; margin-top: 1px }
  li         { margin-bottom: 4px; margin-top: 4px }
  a          { color: blue }
  a:hover    { color: red }
  -->
</style>
</head>
<body>
<h1><a name="top"></a>[10] Constructors<br>
<small><small>(Part of <a href="index.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>, <a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">Copyright&nbsp;&copy; 1991-2003</a>, <a href="http://www.parashift.com/" title="www.parashift.com/" target='_blank'>Marshall Cline</a>, <a href="mailto:cline@parashift.com" title="cline@parashift.com"><tt>cline@parashift.com</tt></a>)</small></small></h1>
<hr>
<h3>FAQs in section [10]:</h3>
<ul>
<li><a href="ctors.html#faq-10.1" title="[10.1] What's the deal with constructors?">[10.1] What's the deal with constructors?</a></li>
<li><a href="ctors.html#faq-10.2" title="[10.2] Is there any difference between List x; and List x();?">[10.2] Is there any difference between <nobr><tt>List x;</tt></nobr> and <nobr><tt>List x();</tt></nobr>?</a></li>
<li><a href="ctors.html#faq-10.3" title="[10.3] Can one constructor of a class call another constructor of the same class to initialize the this object?">[10.3] Can one constructor of a class call another constructor of the same class to initialize the <tt>this</tt> object?</a></li>
<li><a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">[10.4] Is the default constructor for <tt>Fred</tt> always <nobr><tt>Fred::Fred()</tt></nobr>?</a></li>
<li><a href="ctors.html#faq-10.5" title="[10.5] Which constructor gets called when I create an array of Fred objects?">[10.5] Which constructor gets called when I create an array of <tt>Fred</tt> objects?</a></li>
<li><a href="ctors.html#faq-10.6" title="[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?">[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?</a></li>
<li><a href="ctors.html#faq-10.7" title="[10.7] Should you use the this pointer in the constructor?">[10.7] Should you use the <tt>this</tt> pointer in the constructor?</a></li>
<li><a href="ctors.html#faq-10.8" title="[10.8] What is the &quot;Named Constructor Idiom&quot;?">[10.8] What is the &quot;Named Constructor Idiom&quot;?</a></li>
<li><a href="ctors.html#faq-10.9" title="[10.9] Why can't I initialize my static member data in my constructor's initialization list?">[10.9] Why can't I initialize my <tt>static</tt> member data in my constructor's initialization list?</a></li>
<li><a href="ctors.html#faq-10.10" title="[10.10] Why are classes with static data members getting linker errors?">[10.10] Why are classes with <tt>static</tt> data members getting linker errors?</a></li>
<li><a href="ctors.html#faq-10.11" title="[10.11] What's the &quot;static initialization order fiasco&quot;?">[10.11] What's the &quot;<tt>static</tt> initialization order fiasco&quot;?</a></li>
<li><a href="ctors.html#faq-10.12" title="[10.12] How do I prevent the &quot;static initialization order fiasco&quot;?">[10.12] How do I prevent the &quot;<tt>static</tt> initialization order fiasco&quot;?</a></li>
<li><a href="ctors.html#faq-10.13" title="[10.13] Why doesn't the construct-on-first-use idiom use a static object instead of a static pointer?">[10.13] Why doesn't the construct-on-first-use idiom use a static object instead of a static pointer?</a></li>
<li><a href="ctors.html#faq-10.14" title="[10.14] How do I prevent the &quot;static initialization order fiasco&quot; for my static data members?">[10.14] How do I prevent the &quot;<tt>static</tt> initialization order fiasco&quot; for my <tt>static</tt> data members?</a></li>
<li><a href="ctors.html#faq-10.15" title="[10.15] Do I need to worry about the &quot;static initialization order fiasco&quot; for variables of built-in/intrinsic types?">[10.15] Do I need to worry about the &quot;<tt>static</tt> initialization order fiasco&quot; for variables of built-in/intrinsic types?</a></li>
<li><a href="ctors.html#faq-10.16" title="[10.16] How can I handle a constructor that fails?">[10.16] How can I handle a constructor that fails?</a></li>
<li><a href="ctors.html#faq-10.17" title="[10.17] What is the &quot;Named Parameter Idiom&quot;?">[10.17] What is the &quot;Named Parameter Idiom&quot;?</a></li>
</ul>
<p><hr>
<p><a name="faq-10.1"></a>
<div class=FaqTitle><h3>[10.1] What's the deal with constructors?</h3></div>
<p>Constructors build objects from dust.
<p>Constructors are like &quot;init functions&quot;.  They turn a pile of arbitrary bits
into a living object.  Minimally they initialize internally used fields.  They
may also allocate resources (memory, files, semaphores, sockets, etc).
<p>&quot;ctor&quot; is a typical abbreviation for constructor.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.2"></a>
<div class=FaqTitle><h3>[10.2] Is there any difference between <nobr><tt>List x;</tt></nobr> and <nobr><tt>List x();</tt></nobr>?</h3></div>
<p>A <em>big</em> difference!
<p>Suppose that <tt>List</tt> is the name of some class.  Then function <nobr><tt>f()</tt></nobr> declares
a local <tt>List</tt> object called <tt>x</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;f()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;List&nbsp;x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Local&nbsp;object&nbsp;named&nbsp;<tt>x</tt>&nbsp;(of&nbsp;class&nbsp;<tt>List</tt>)</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>But function <nobr><tt>g()</tt></nobr> declares a function called <nobr><tt>x()</tt></nobr> that returns a
<tt>List</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;g()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;List&nbsp;x();&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Function&nbsp;named&nbsp;<tt>x</tt>&nbsp;(that&nbsp;returns&nbsp;a&nbsp;<tt>List</tt>)</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.3"></a>
<div class=FaqTitle><h3>[10.3] Can one constructor of a class call another constructor of the same class to initialize the <tt>this</tt> object?</h3></div>
<p>Nope.
<p>Let's work an example.  Suppose you want your constructor
<nobr><tt>Foo::Foo(char)</tt></nobr> to call another constructor of the same class, say
<nobr><tt>Foo::Foo(char,int)</tt></nobr>, in order that <nobr><tt>Foo::Foo(char,int)</tt></nobr> would
help initialize the <tt>this</tt> object.  Unfortunately there's no way to do this in
C++.
<p>Some people do it anyway.  Unfortunately it doesn't do what they want.  For
example, the line <nobr><tt>Foo(x, 0);</tt></nobr> does <em>not</em> call
<nobr><tt>Foo::Foo(char,int)</tt></nobr> on the <tt>this</tt> object.  Instead it calls
<nobr><tt>Foo::Foo(char,int)</tt></nobr> to initialize a temporary, local object
(<em>not</em> <tt>this</tt>), then it immediately destructs that temporary when
control flows over the <nobr><tt>;</tt></nobr>.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x);<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x,&nbsp;int&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;Foo::Foo(char&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;Foo(x,&nbsp;0);&nbsp;&nbsp;</tt><em>//&nbsp;this&nbsp;line&nbsp;does&nbsp;NOT&nbsp;help&nbsp;initialize&nbsp;the&nbsp;<tt>this</tt>&nbsp;object!!</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>You can sometimes combine two constructors is via a default parameter:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x,&nbsp;int&nbsp;y=0);&nbsp;&nbsp;</tt><em>//&nbsp;this&nbsp;line&nbsp;combines&nbsp;the&nbsp;two&nbsp;constructors</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};
</tt>
</div>
<p>If that doesn't work, e.g., if there isn't an appropriate default parameter
that combines the two constructors, sometimes you can share their common code
in a private <nobr><tt>init()</tt></nobr> member function:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Foo&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x);<br>
&nbsp;&nbsp;&nbsp;Foo(char&nbsp;x,&nbsp;int&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;void&nbsp;init(char&nbsp;x,&nbsp;int&nbsp;y);<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;Foo::Foo(char&nbsp;x)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;init(x,&nbsp;int(x)&nbsp;+&nbsp;7);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Foo::Foo(char&nbsp;x,&nbsp;int&nbsp;y)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;init(x,&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;Foo::init(char&nbsp;x,&nbsp;int&nbsp;y)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.4"></a>
<div class=FaqTitle><h3>[10.4] Is the default constructor for <tt>Fred</tt> always <nobr><tt>Fred::Fred()</tt></nobr>?</h3></div>
<p>No.  A &quot;default constructor&quot; is a constructor that <em>can be called</em> with
no arguments.  One example of this is a constructor that takes no parameters:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred();&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Default&nbsp;constructor:&nbsp;can&nbsp;be&nbsp;called&nbsp;with&nbsp;no&nbsp;args</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};
</tt>
</div>
<p>Another example of a &quot;default constructor&quot; is one that can take arguments,
provided they are given default values:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred(int&nbsp;i=3,&nbsp;int&nbsp;j=5);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Default&nbsp;constructor:&nbsp;can&nbsp;be&nbsp;called&nbsp;with&nbsp;no&nbsp;args</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.5"></a>
<div class=FaqTitle><h3>[10.5] Which constructor gets called when I create an array of <tt>Fred</tt> objects?</h3></div>
<p><tt>Fred</tt>'s <a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default constructor<!--rawtext:[10.4]:rawtext--></a> (except as discussed
below).
<p>There is no way to tell the compiler to call a different constructor (except as
discussed below).  If your <tt>class</tt> <tt>Fred</tt> doesn't have a <a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default constructor<!--rawtext:[10.4]:rawtext--></a>, attempting to create an array of <tt>Fred</tt> objects is
trapped as an error at compile time.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred(int&nbsp;i,&nbsp;int&nbsp;j);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...assume&nbsp;there&nbsp;is&nbsp;no&nbsp;<a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default&nbsp;constructor<!--rawtext:[10.4]:rawtext--></a>&nbsp;in&nbsp;<tt>class</tt>&nbsp;<tt>Fred</tt>...</em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;a[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;ERROR:&nbsp;<tt>Fred</tt>&nbsp;doesn't&nbsp;have&nbsp;a&nbsp;default&nbsp;constructor</em><tt><br>
&nbsp;&nbsp;&nbsp;Fred*&nbsp;p&nbsp;=&nbsp;new&nbsp;Fred[10];&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;ERROR:&nbsp;<tt>Fred</tt>&nbsp;doesn't&nbsp;have&nbsp;a&nbsp;default&nbsp;constructor</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>However if you are constructing an object of <a href="class-libraries.html#faq-36.1" title="[36.1] What is the &quot;STL&quot;?">the standard
<nobr><tt>std::vector&lt;Fred&gt;</tt></nobr><!--rawtext:[36.1]:rawtext--></a> rather than an array of <tt>Fred</tt> (which you probably should
be doing anyway since <a href="containers-and-templates.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">arrays are evil<!--rawtext:[34.1]:rawtext--></a>), you don't
have to have a default constructor in <tt>class</tt> <tt>Fred</tt>, since you can give the
<nobr><tt>std::vector</tt></nobr> a <tt>Fred</tt> object to be used to initialize the elements:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;vector&gt;<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::vector&lt;Fred&gt;&nbsp;a(10,&nbsp;Fred(5,7));<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;The&nbsp;10&nbsp;<tt>Fred</tt>&nbsp;objects&nbsp;in&nbsp;<nobr><tt>std::vector</tt></nobr>&nbsp;<tt>a</tt>&nbsp;will&nbsp;be&nbsp;initialized&nbsp;with&nbsp;<nobr><tt>Fred(5,7)</tt></nobr>.</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>Even though you <em>ought</em> to use a <nobr><tt>std::vector</tt></nobr> rather than an array,
there are times when an array might be the right thing to do, and for those,
there is the &quot;explicit initialization of arrays&quot; syntax.  Here's how it looks:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred(int&nbsp;i,&nbsp;int&nbsp;j);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...assume&nbsp;there&nbsp;is&nbsp;no&nbsp;<a href="ctors.html#faq-10.4" title="[10.4] Is the default constructor for Fred always Fred::Fred()?">default&nbsp;constructor<!--rawtext:[10.4]:rawtext--></a>&nbsp;in&nbsp;<tt>class</tt>&nbsp;<tt>Fred</tt>...</em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;a[10]&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7),&nbsp;Fred(5,7)<br>
&nbsp;&nbsp;&nbsp;};<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;The&nbsp;10&nbsp;<tt>Fred</tt>&nbsp;objects&nbsp;in&nbsp;array&nbsp;<tt>a</tt>&nbsp;will&nbsp;be&nbsp;initialized&nbsp;with&nbsp;<nobr><tt>Fred(5,7)</tt></nobr>.</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>Of course you don't have to do <nobr><tt>Fred(5,7)</tt></nobr> for every entry &#151; you can put
in any numbers you want, even parameters or other variables.  The point is that
this syntax is (a) doable but (b) not as nice as the <nobr><tt>std::vector</tt></nobr> syntax.  Remember
this: <a href="containers-and-templates.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">arrays are evil<!--rawtext:[34.1]:rawtext--></a> &#151; unless there is a
compelling reason to use an array, use a <nobr><tt>std::vector</tt></nobr> instead.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.6"></a>
<div class=FaqTitle><h3>[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?</h3></div>
<p>Initialization lists.  In fact, constructors should initialize <em>all</em>
member objects in the initialization list.
<p>For example, this constructor initializes member object <tt>x_</tt> using an
initialization list: <nobr><tt>Fred::Fred() : x_(</tt></nobr><em>whatever</em><nobr><tt>)
{&nbsp;}</tt></nobr>.  The most common benefit of doing this is improved performance.
For example, if the expression <em>whatever</em> is the same as member variable
<tt>x_</tt>, the result of the <em>whatever</em> expression is constructed
directly inside <tt>x_</tt> &#151; the compiler does not make a separate copy of
the object.  Even if the types are not the same, the compiler is usually able
to do a better job with initialization lists than with assignments.
<p>The other (inefficient) way to build constructors is via assignment, such as:
<nobr><tt>Fred::Fred() {&nbsp;x_&nbsp;=&nbsp;</tt></nobr><em>whatever</em><nobr><tt>;&nbsp;}</tt></nobr>.  In this
case the expression <em>whatever</em> causes a separate, temporary object to be
created, and this temporary object is passed into the <tt>x_</tt> object's
assignment operator.  Then that temporary object is destructed at the
<nobr><tt>;</tt></nobr>.  That's inefficient.
<p>As if that wasn't bad enough, there's another source of inefficiency when
using assignment in a constructor: the member object will get fully constructed
by its default constructor, and this might, for example, allocate some default
amount of memory or open some default file.  All this work could be for naught
if the <em>whatever</em> expression and/or assignment operator causes the
object to close that file and/or release that memory (e.g., if the default
constructor didn't allocate a large enough pool of memory or if it opened the
wrong file).
<p>Conclusion: All other things being equal, your code will run faster if you use
initialization lists rather than assignment.
<p>Note: There is no performance difference if the type of <tt>x_</tt> is some
built-in/intrinsic type, such as <tt>int</tt> or <nobr><tt>char*</tt></nobr> or <tt>float</tt>.  But even in
these cases, my personal preference is to set those data members in the
initialization list rather than via assignment for consistency.  Another
symmetry argument in favor of using initialization lists even for
built-in/intrinsic types: non-static <tt>const</tt> data members <em>can't</em> be
assigned a value in the constructor, so for symmetry it makes sense to
initialize everything in the initialization list.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.7"></a>
<div class=FaqTitle><h3>[10.7] Should you use the <tt>this</tt> pointer in the constructor?</h3></div>
<p>Some people feel you should not use the <tt>this</tt> pointer in a constructor
because the object is not fully formed yet.  However you can use <tt>this</tt>
in the constructor (in the <nobr><tt>{</tt></nobr>body<nobr><tt>}</tt></nobr> and even in the <a href="ctors.html#faq-10.6" title="[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?">initialization list<!--rawtext:[10.6]:rawtext--></a>) if you are careful.
<p>Here is something that <em>always</em> works: the <nobr><tt>{</tt></nobr>body<nobr><tt>}</tt></nobr> of a constructor
(or a function called from the constructor) can reliably access the data
members declared in a base class and/or the data members declared in the
constructor's own class.  This is because all those data members are
guaranteed to have been fully constructed by the time the constructor's
<nobr><tt>{</tt></nobr>body<nobr><tt>}</tt></nobr> starts executing.
<p>Here is something that <em>never</em> works: the <nobr><tt>{</tt></nobr>body<nobr><tt>}</tt></nobr> of a constructor
(or a function called from the constructor) can<em>not</em> get down to a
derived class by calling a <tt>virtual</tt> member function that is overridden in the
derived class.  If your goal was to get to the overridden function in the
derived class, <a href="strange-inheritance.html#faq-23.3" title="[23.3] When my base class's constructor calls a virtual function on its this object, why doesn't my derived class's override of that virtual function get invoked?">you won't get what you
want<!--rawtext:[23.3]:rawtext--></a>.  Note that you won't get to the override in the derived class
independent of <em>how</em> you call the <tt>virtual</tt> member function: explicitly
using the <tt>this</tt> pointer (e.g., <nobr><tt>this-&gt;method()</tt></nobr>), implicitly using the
<tt>this</tt> pointer (e.g., <nobr><tt>method()</tt></nobr>), or even calling some other function
that calls the <tt>virtual</tt> member function on your <tt>this</tt> object.  The bottom
line is this: even if the caller is constructing an object of a derived class,
during the constructor of the base class, <a href="strange-inheritance.html#faq-23.3" title="[23.3] When my base class's constructor calls a virtual function on its this object, why doesn't my derived class's override of that virtual function get invoked?">your object is not yet of that derived class<!--rawtext:[23.3]:rawtext--></a>.  You have been warned.
<p>Here is something that <em>sometimes</em> works: if you pass any of the data
members in <tt>this</tt> object to another data member's <a href="ctors.html#faq-10.6" title="[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?">initializer<!--rawtext:[10.6]:rawtext--></a>, you must make sure that the other data member has already
been initialized.  The good news is that you can determine whether the other
data member has (or has not) been initialized using some straightforward
language rules that are independent of the particular compiler you're using.
The bad news it that you have to know those language rules (e.g., base class
sub-objects are initialized first (look up the order if you have multiple
and/or <tt>virtual</tt> inheritance!), then data members defined in the class are
initialized in the order in which they appear in the class declaration).  If
you don't know these rules, then don't pass any data member from the <tt>this</tt>
object (regardless of whether or not you explicitly use the <tt>this</tt> keyword) to
any other data member's <a href="ctors.html#faq-10.6" title="[10.6] Should my constructors use &quot;initialization lists&quot; or &quot;assignment&quot;?">initializer<!--rawtext:[10.6]:rawtext--></a>!  And if you do
know the rules, please be careful.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.8"></a>
<div class=FaqTitle><h3>[10.8] What is the &quot;Named Constructor Idiom&quot;?</h3></div>
<p>A technique that provides more intuitive and/or safer construction operations
for users of your class.
<p>The problem is that constructors always have the same name as the class.
Therefore the only way to differentiate between the various constructors of a
class is by the parameter list.  But if there are lots of constructors, the
differences between them become somewhat subtle and error prone.
<p>With the Named Constructor Idiom, you declare all the class's constructors in
the <tt>private</tt> or <tt>protected</tt> sections, and you provide <tt>public</tt> <tt>static</tt>
methods that return an object.  These <tt>static</tt> methods are the so-called &quot;Named
Constructors.&quot; In general there is one such <tt>static</tt> method for each different
way to construct an object.
<p>For example, suppose we are building a <tt>Point</tt> class that represents a position
on the X-Y plane.  Turns out there are two common ways to specify a 2-space
coordinate: rectangular coordinates (X+Y), polar coordinates (Radius+Angle).
(Don't worry if you can't remember these; the point isn't the particulars of
coordinate systems; the point is that there are several ways to create a
<tt>Point</tt> object.) Unfortunately the parameters for these two coordinate systems
are the same: two <tt>float</tt>s.  This would create an ambiguity error in the
overloaded constructors:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Point&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Point(float&nbsp;x,&nbsp;float&nbsp;y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Rectangular&nbsp;coordinates</em><tt><br>
&nbsp;&nbsp;&nbsp;Point(float&nbsp;r,&nbsp;float&nbsp;a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Polar&nbsp;coordinates&nbsp;(radius&nbsp;and&nbsp;angle)</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;ERROR:&nbsp;Overload&nbsp;is&nbsp;Ambiguous:&nbsp;<nobr><tt>Point::Point(float,float)</tt></nobr></em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Point&nbsp;p&nbsp;=&nbsp;Point(5.7,&nbsp;1.2);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Ambiguous:&nbsp;Which&nbsp;coordinate&nbsp;system?</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>One way to solve this ambiguity is to use the Named Constructor Idiom:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;cmath&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;To&nbsp;get&nbsp;<nobr><tt>sin()</tt></nobr>&nbsp;and&nbsp;<nobr><tt>cos()</tt></nobr></em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;Point&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Point&nbsp;rectangular(float&nbsp;x,&nbsp;float&nbsp;y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Rectangular&nbsp;coord's</em><tt><br>
&nbsp;&nbsp;&nbsp;static&nbsp;Point&nbsp;polar(float&nbsp;radius,&nbsp;float&nbsp;angle);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Polar&nbsp;coordinates</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;These&nbsp;<tt>static</tt>&nbsp;methods&nbsp;are&nbsp;the&nbsp;so-called&nbsp;&quot;named&nbsp;constructors&quot;</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;Point(float&nbsp;x,&nbsp;float&nbsp;y);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Rectangular&nbsp;coordinates</em><tt><br>
&nbsp;&nbsp;&nbsp;float&nbsp;x_,&nbsp;y_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;inline&nbsp;Point::Point(float&nbsp;x,&nbsp;float&nbsp;y)<br>
&nbsp;:&nbsp;x_(x),&nbsp;y_(y)&nbsp;{&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;Point&nbsp;Point::rectangular(float&nbsp;x,&nbsp;float&nbsp;y)<br>
&nbsp;{&nbsp;return&nbsp;Point(x,&nbsp;y);&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;Point&nbsp;Point::polar(float&nbsp;radius,&nbsp;float&nbsp;angle)<br>
&nbsp;{&nbsp;return&nbsp;Point(radius*cos(angle),&nbsp;radius*sin(angle));&nbsp;}
</tt>
</div>
<p>Now the users of <tt>Point</tt> have a clear and unambiguous syntax for creating
<tt>Point</tt>s in either coordinate system:
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Point&nbsp;p1&nbsp;=&nbsp;Point::rectangular(5.7,&nbsp;1.2);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Obviously&nbsp;rectangular</em><tt><br>
&nbsp;&nbsp;&nbsp;Point&nbsp;p2&nbsp;=&nbsp;Point::polar(5.7,&nbsp;1.2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Obviously&nbsp;polar</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>Make sure your constructors are in the <tt>protected</tt> section if you expect
<tt>Point</tt> to have derived classes.
<p>The Named Constructor Idiom can also be used to <a href="freestore-mgmt.html#faq-16.20" title="[16.20] How can I force objects of my class to always be created via new rather than as locals or global/static objects?">make sure your objects are always created via <tt>new</tt><!--rawtext:[16.20]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.9"></a>
<div class=FaqTitle><h3>[10.9] Why can't I initialize my <tt>static</tt> member data in my constructor's initialization list?</h3></div>
<p>Because you must <em>explicitly</em> define your class's <tt>static</tt> data
members.
<p><tt>Fred.h</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Fred();<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;int&nbsp;i_;<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;j_;<br>
&nbsp;};
</tt>
</div>
<p><tt>Fred.cpp</tt> (or <tt>Fred.C</tt> or whatever):
<p><div class=CodeBlock>
<tt>
&nbsp;Fred::Fred()<br>
&nbsp;&nbsp;&nbsp;:&nbsp;i_(10)&nbsp;&nbsp;</tt><em>//&nbsp;OK:&nbsp;you&nbsp;can&nbsp;(and&nbsp;should)&nbsp;initialize&nbsp;member&nbsp;data&nbsp;this&nbsp;way</em><tt><br>
&nbsp;&nbsp;&nbsp;,&nbsp;j_(42)&nbsp;&nbsp;</tt><em>//&nbsp;Error:&nbsp;you&nbsp;cannot&nbsp;initialize&nbsp;<tt>static</tt>&nbsp;member&nbsp;data&nbsp;like&nbsp;this</em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;</tt><em>//&nbsp;You&nbsp;must&nbsp;define&nbsp;<tt>static</tt>&nbsp;data&nbsp;members&nbsp;this&nbsp;way:</em><tt><br>
&nbsp;int&nbsp;Fred::j_&nbsp;=&nbsp;42;
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.10"></a>
<div class=FaqTitle><h3>[10.10] Why are classes with <tt>static</tt> data members getting linker errors?</h3></div>
<p>Because <a href="ctors.html#faq-10.9" title="[10.9] Why can't I initialize my static member data in my constructor's initialization list?"><tt>static</tt> data members must be
explicitly defined in exactly one compilation unit<!--rawtext:[10.9]:rawtext--></a>.  If you didn't do
this, you'll probably get an <nobr><tt>&quot;undefined external&quot;</tt></nobr> linker error.  For
example:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;Fred.h</em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;j_;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Declares&nbsp;<tt>static</tt>&nbsp;data&nbsp;member&nbsp;<nobr><tt>Fred::j_</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};
</tt>
</div>
<p>The linker will holler at you (<nobr><tt>&quot;Fred::j_ is not defined&quot;</tt></nobr>) unless you
define (as opposed to merely declare) <nobr><tt>Fred::j_</tt></nobr> in (exactly) one of your
source files:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;Fred.cpp</em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;Fred.h&quot;<br>
&nbsp;<br>
&nbsp;int&nbsp;Fred::j_&nbsp;=&nbsp;some_expression_evaluating_to_an_int;<br>
&nbsp;<br>
&nbsp;</tt><em>//&nbsp;Alternatively,&nbsp;if&nbsp;you&nbsp;wish&nbsp;to&nbsp;use&nbsp;the&nbsp;implicit&nbsp;0&nbsp;value&nbsp;for&nbsp;<tt>static</tt>&nbsp;<tt>int</tt>s:</em><tt><br>
&nbsp;</tt><em>//&nbsp;<nobr><tt>int&nbsp;Fred::j_;</tt></nobr></em><tt>
</tt>
</div>
<p>The usual place to define <tt>static</tt> data members of <tt>class</tt> <tt>Fred</tt> is file
<tt>Fred.cpp</tt> (or <tt>Fred.C</tt> or whatever source file extension you use).
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.11"></a>
<div class=FaqTitle><h3>[10.11] What's the &quot;<tt>static</tt> initialization order fiasco&quot;?</h3></div>
<p>A subtle way to kill your project.
<p>The <em><tt>static</tt> initialization order fiasco</em> is a very subtle and commonly
misunderstood aspect of C++.  Unfortunately it's very hard to detect &#151; the
errors occur before <nobr><tt>main()</tt></nobr> begins.
<p>In short, suppose you have two <tt>static</tt> objects <tt>x</tt> and <tt>y</tt> which exist in
separate source files, say <tt>x.cpp</tt> and <tt>y.cpp</tt>.  Suppose further
that the initialization for the <tt>y</tt> object (typically the <tt>y</tt> object's
constructor) calls some method on the <tt>x</tt> object.
<p>That's it.  It's that simple.
<p>The tragedy is that you have a 50%-50% chance of dying.  If the compilation
unit for <tt>x.cpp</tt> happens to get initialized first, all is well.  But if
the compilation unit for <tt>y.cpp</tt> get initialized first, then <tt>y</tt>'s
initialization will get run before <tt>x</tt>'s initialization, and you're toast.
E.g., <tt>y</tt>'s constructor could call a method on the <tt>x</tt> object, yet the <tt>x</tt>
object hasn't yet been constructed.
<p>I hear they're hiring down at McDonalds.  Enjoy your new job flipping burgers.
<p>If you think it's &quot;exciting&quot; to play Russian Roulette with live rounds in half the
chambers, you can stop reading here.  On the other hand if you like to improve
your chances of survival by preventing disasters in a systematic way, you
probably want to read <a href="ctors.html#faq-10.12" title="[10.12] How do I prevent the &quot;static initialization order fiasco&quot;?">the next FAQ<!--rawtext:[10.12]:rawtext--></a>.
<p>Note: The static initialization order fiasco can also,
<a href="ctors.html#faq-10.15" title="[10.15] Do I need to worry about the &quot;static initialization order fiasco&quot; for variables of built-in/intrinsic types?">in some cases<!--rawtext:[10.15]:rawtext--></a>, apply to
built-in/intrinsic types.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.12"></a>
<div class=FaqTitle><h3>[10.12] How do I prevent the &quot;<tt>static</tt> initialization order fiasco&quot;?</h3></div>
<p>Use the &quot;construct on first use&quot; idiom, which simply means to wrap your
<tt>static</tt> object inside a function.
<p>For example, suppose you have two classes, <tt>Fred</tt> and <tt>Barney</tt>.
There is a global <tt>Fred</tt> object called <tt>x</tt>, and a global <tt>Barney</tt>
object called <tt>y</tt>.  <tt>Barney</tt>'s constructor invokes the
<nobr><tt>goBowling()</tt></nobr> method on the <tt>x</tt> object.  The file <tt>x.cpp</tt> defines
the <tt>x</tt> object:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;x.cpp</em><tt><br>
&nbsp;#include&nbsp;&quot;Fred.hpp&quot;<br>
&nbsp;Fred&nbsp;x;
</tt>
</div>
<p>The file <tt>y.cpp</tt> defines the <tt>y</tt> object:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;y.cpp</em><tt><br>
&nbsp;#include&nbsp;&quot;Barney.hpp&quot;<br>
&nbsp;Barney&nbsp;y;
</tt>
</div>
<p>For completeness the <tt>Barney</tt> constructor might look something like this:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;Barney.cpp</em><tt><br>
&nbsp;#include&nbsp;&quot;Barney.hpp&quot;<br>
&nbsp;<br>
&nbsp;Barney::Barney()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;x.goBowling();<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>As described <a href="ctors.html#faq-10.11" title="[10.11] What's the &quot;static initialization order fiasco&quot;?">above<!--rawtext:[10.11]:rawtext--></a>, the disaster occurs if <tt>y</tt> is
constructed before <tt>x</tt>, which happens 50% of the time since they're in
different source files.
<p>There are many solutions to this problem, but a very simple and completely
portable solution is to replace the global <tt>Fred</tt> object, <tt>x</tt>, with a
global function, <nobr><tt>x()</tt></nobr>, that returns the <tt>Fred</tt> object by reference.
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;x.cpp</em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;Fred.hpp&quot;<br>
&nbsp;<br>
&nbsp;Fred&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred*&nbsp;ans&nbsp;=&nbsp;new&nbsp;Fred();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;*ans;<br>
&nbsp;}
</tt>
</div>
<p>Since <tt>static</tt> local objects are constructed the first time control flows over
their declaration (only), the above <nobr><tt>new Fred()</tt></nobr> statement will only
happen once: the first time <nobr><tt>x()</tt></nobr> is called.  Every subsequent call will return
the same <tt>Fred</tt> object (the one pointed to by <tt>ans</tt>).  Then all you
do is change your usages of <tt>x</tt> to <nobr><tt>x()</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;Barney.cpp</em><tt><br>
&nbsp;#include&nbsp;&quot;Barney.hpp&quot;<br>
&nbsp;<br>
&nbsp;Barney::Barney()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;x().goBowling();<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>This is called the <em>Construct On First Use Idiom</em> because it does just
that: the global <tt>Fred</tt> object is constructed on its first use.
<p>The downside of this approach is that the <tt>Fred</tt> object is never
destructed.  There is <a href="ctors.html#faq-10.13" title="[10.13] Why doesn't the construct-on-first-use idiom use a static object instead of a static pointer?">another technique<!--rawtext:[10.13]:rawtext--></a>
that answers this concern, but it needs to be used with care since it creates
the possibility of another (equally nasty) problem.
<p>Note: The static initialization order fiasco can also,
<a href="ctors.html#faq-10.15" title="[10.15] Do I need to worry about the &quot;static initialization order fiasco&quot; for variables of built-in/intrinsic types?">in some cases<!--rawtext:[10.15]:rawtext--></a>, apply to
built-in/intrinsic types.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.13"></a>
<div class=FaqTitle><h3>[10.13] Why doesn't the construct-on-first-use idiom use a static object instead of a static pointer?</h3></div>
<p>Short answer: it's possible to use a static object
<a href="ctors.html#faq-10.12" title="[10.12] How do I prevent the &quot;static initialization order fiasco&quot;?">rather than a static pointer<!--rawtext:[10.12]:rawtext--></a>, but
doing so opens up another (equally subtle, equally nasty) problem.
<p>Long answer: sometimes people worry about the fact that
<a href="ctors.html#faq-10.12" title="[10.12] How do I prevent the &quot;static initialization order fiasco&quot;?">the previous solution<!--rawtext:[10.12]:rawtext--></a> &quot;leaks.&quot; In
many cases, this is not a problem, but it is a problem in some cases.  Note:
even though the object pointed to by <tt>ans</tt> in the previous FAQ is never
deleted, the memory doesn't actually &quot;leak&quot; when the program exits since the
operating system automatically reclaims all the memory in a program's heap
when that program exits.  In other words, the only time you'd need to worry
about this is when the destructor for the <tt>Fred</tt> object performs some
important action (such as writing something to a file) that must occur
sometime while the program is exiting.
<p>In those cases where the construct-on-first-use object (the <tt>Fred</tt>, in
this case) needs to eventually get destructed, you might consider changing
function <nobr><tt>x()</tt></nobr> as follows:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;x.cpp</em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;Fred.hpp&quot;<br>
&nbsp;<br>
&nbsp;Fred&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&nbsp;ans;&nbsp;&nbsp;</tt><em>//&nbsp;was&nbsp;<nobr><tt>static&nbsp;Fred*&nbsp;ans&nbsp;=&nbsp;new&nbsp;Fred();</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;was&nbsp;<nobr><tt>return&nbsp;*ans;</tt></nobr></em><tt><br>
&nbsp;}
</tt>
</div>
<p>However there is (or rather, may be) a rather subtle problem with this change.
To understand this potential problem, let's remember why we're doing all this
in the first place: we need to make 100% sure our static object (a) gets
constructed prior to its first use and (b) doesn't get destructed until after
its last use.  Obviously it would be a disaster if any static object got used
either before construction or after destruction.  The message here is that you
need to worry about two situations (static initialization and static
deinitialization), not just one.
<p>By changing the declaration from <nobr><tt>static Fred* ans = new Fred();</tt></nobr> to
<nobr><tt>static Fred ans;</tt></nobr>, we still correctly handle the initialization
situation but we no longer handle the deinitialization situation.  For
example, if there are 3 static objects, say <tt>a</tt>, <tt>b</tt> and
<tt>c</tt>, that use <tt>ans</tt> during their destructors, the only way to
avoid a static deinitialization disaster is if <tt>ans</tt> is destructed after
all three.
<p>The point is simple: if there are any other static objects whose destructors
might use <tt>ans</tt> after <tt>ans</tt> is destructed, bang, you're dead.  If
the <em>constructors</em> of <tt>a</tt>, <tt>b</tt> and <tt>c</tt> use
<tt>ans</tt>, you <em>should</em> normally be okay since the runtime system
will, during static deinitialization, destruct <tt>ans</tt> after the last of
those three objects is destructed.  However if <tt>a</tt> and/or <tt>b</tt>
and/or <tt>c</tt> fail to use <tt>ans</tt> in their constructors and/or if any
code anywhere gets the address of <tt>ans</tt> and hands it to some other
static object, all bets are off and you have to be very, very careful.
<p>There is a third approach that handles both the static initialization and
static deinitialization situations, but it has other non-trivial costs.  I'm
too lazy (and busy!) to write any more FAQs today so if you're interested in
that third approach, you'll have to buy a book that describes that third
approach in detail.  The <a href="faq-book.html#faq-3.1" title="[3.1] Is there a C++ FAQ Book in addition to the C++ FAQ Lite?">C++ FAQs book<!--rawtext:[3.1]:rawtext--></a> is one of
those books, and it also gives the cost/benefit analysis to decide if/when
that third approach should be used.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.14"></a>
<div class=FaqTitle><h3>[10.14] How do I prevent the &quot;<tt>static</tt> initialization order fiasco&quot; for my <tt>static</tt> data members?</h3></div>
<p>Just use <a href="ctors.html#faq-10.12" title="[10.12] How do I prevent the &quot;static initialization order fiasco&quot;?">the same technique just
described<!--rawtext:[10.12]:rawtext--></a>, but this time use a <tt>static</tt> member function rather than a
global function.
<p>Suppose you have a class <tt>X</tt> that has a <tt>static</tt> <tt>Fred</tt> object:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;X.hpp</em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;X&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&nbsp;x_;<br>
&nbsp;};
</tt>
</div>
<p>Naturally this <tt>static</tt> member is initialized separately:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;X.cpp</em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;X.hpp&quot;<br>
&nbsp;<br>
&nbsp;Fred&nbsp;X::x_;
</tt>
</div>
<p>Naturally also the <tt>Fred</tt> object will be used in one or more of
<tt>X</tt>'s methods:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;X::someMethod()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x_.goBowling();<br>
&nbsp;}
</tt>
</div>
<p>But now the &quot;disaster scenario&quot; is if someone somewhere somehow calls this
method before the <tt>Fred</tt> object gets constructed.  For example, if
someone else creates a static <tt>X</tt> object and invokes its
<nobr><tt>someMethod()</tt></nobr> method during <tt>static</tt> initialization, then you're at the
mercy of the compiler as to whether the compiler will construct <nobr><tt>X::x_</tt></nobr>
before or after the <nobr><tt>someMethod()</tt></nobr> is called.  (Note that the ANSI/ISO
C++ committee is working on this problem, but compilers aren't yet generally
available that handle these changes; watch this space for an update in the
future.)
<p>In any event, it's always portable and safe to change the <nobr><tt>X::x_</tt></nobr>
<tt>static</tt> data member into a <tt>static</tt> member function:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;X.hpp</em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;X&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&amp;&nbsp;x();<br>
&nbsp;};
</tt>
</div>
<p>Naturally this <tt>static</tt> member is initialized separately:
<p><div class=CodeBlock>
<tt>
&nbsp;</tt><em>//&nbsp;File&nbsp;X.cpp</em><tt><br>
&nbsp;<br>
&nbsp;#include&nbsp;&quot;X.hpp&quot;<br>
&nbsp;<br>
&nbsp;Fred&amp;&nbsp;X::x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred*&nbsp;ans&nbsp;=&nbsp;new&nbsp;Fred();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;*ans;<br>
&nbsp;}
</tt>
</div>
<p>Then you simply change any usages of <tt>x_</tt> to <nobr><tt>x()</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;X::someMethod()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;x().goBowling();<br>
&nbsp;}
</tt>
</div>
<p>If you're super performance sensitive and you're concerned about the overhead
of an extra function call on each invocation of <nobr><tt>X::someMethod()</tt></nobr> you can
set up a <tt>static</tt> <nobr><tt>Fred&amp;</tt></nobr> instead.  As you recall, <tt>static</tt> local are
only initialized once (the first time control flows over their declaration), so
this will call <nobr><tt>X::x()</tt></nobr> only once: the first time <nobr><tt>X::someMethod()</tt></nobr>
is called:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;X::someMethod()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;Fred&amp;&nbsp;x&nbsp;=&nbsp;X::x();<br>
&nbsp;&nbsp;&nbsp;x.goBowling();<br>
&nbsp;}
</tt>
</div>
<p>Note: The static initialization order fiasco can also,
<a href="ctors.html#faq-10.15" title="[10.15] Do I need to worry about the &quot;static initialization order fiasco&quot; for variables of built-in/intrinsic types?">in some cases<!--rawtext:[10.15]:rawtext--></a>, apply to
built-in/intrinsic types.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.15"></a>
<div class=FaqTitle><h3>[10.15] Do I need to worry about the &quot;<tt>static</tt> initialization order fiasco&quot; for variables of built-in/intrinsic types?</h3></div>
<p>Yes.
<p>If you initialize your built-in/intrinsic type using a function call, the
static initialization order fiasco is able to kill you just as bad as with
user-defined/class types.  For example, the following code shows the failure:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;<br>
&nbsp;int&nbsp;f();&nbsp;&nbsp;</tt><em>//&nbsp;forward&nbsp;declaration</em><tt><br>
&nbsp;int&nbsp;g();&nbsp;&nbsp;</tt><em>//&nbsp;forward&nbsp;declaration</em><tt><br>
&nbsp;<br>
&nbsp;int&nbsp;x&nbsp;=&nbsp;f();<br>
&nbsp;int&nbsp;y&nbsp;=&nbsp;g();<br>
&nbsp;<br>
&nbsp;int&nbsp;f()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;using&nbsp;'y'&nbsp;(which&nbsp;is&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;y&nbsp;&lt;&lt;&nbsp;&quot;)\n&quot;;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;3*y&nbsp;+&nbsp;7;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&nbsp;g()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;initializing&nbsp;'y'\n&quot;;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;5;<br>
&nbsp;}
</tt>
</div>
<p>The output of this little program will show that it uses <tt>y</tt> before
initializing it.  The solution, as before, is the <em>Construct On First Use
Idiom</em>:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;<br>
&nbsp;int&nbsp;f();&nbsp;&nbsp;</tt><em>//&nbsp;forward&nbsp;declaration</em><tt><br>
&nbsp;int&nbsp;g();&nbsp;&nbsp;</tt><em>//&nbsp;forward&nbsp;declaration</em><tt><br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans&nbsp;=&nbsp;f();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;y()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans&nbsp;=&nbsp;g();<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&nbsp;f()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;using&nbsp;'y'&nbsp;(which&nbsp;is&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;y()&nbsp;&lt;&lt;&nbsp;&quot;)\n&quot;;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;3*y()&nbsp;+&nbsp;7;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&nbsp;g()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;initializing&nbsp;'y'\n&quot;;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;5;<br>
&nbsp;}
</tt>
</div>
<p>Of course you might be able to simplify this by moving the initialization code
for <tt>x</tt> and <tt>y</tt> into their respective functions:
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;iostream&gt;<br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;y();&nbsp;&nbsp;</tt><em>//&nbsp;forward&nbsp;declaration</em><tt><br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;static&nbsp;bool&nbsp;firstTime&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(firstTime)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstTime&nbsp;=&nbsp;false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;using&nbsp;'y'&nbsp;(which&nbsp;is&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;y()&nbsp;&lt;&lt;&nbsp;&quot;)\n&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;3*y()&nbsp;+&nbsp;7;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;y()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans;<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;static&nbsp;bool&nbsp;firstTime&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(firstTime)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstTime&nbsp;=&nbsp;false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;&quot;initializing&nbsp;'y'\n&quot;;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans&nbsp;=&nbsp;5;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}
</tt>
</div>
<p>And, if you can get rid of the print statements you can further simplify these
to something really simple:
<p><div class=CodeBlock>
<tt>
&nbsp;int&amp;&nbsp;y();&nbsp;&nbsp;</tt><em>//&nbsp;forward&nbsp;declaration</em><tt><br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;x()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans&nbsp;=&nbsp;3*y()&nbsp;+&nbsp;7;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;int&amp;&nbsp;y()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;ans&nbsp;=&nbsp;5;<br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}
</tt>
</div>
<p>Furthermore, since <tt>y</tt> is initialized using a constant expression, it no
longer needs its wrapper function &#151; it can be a simple variable again.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.16"></a>
<div class=FaqTitle><h3>[10.16] How can I handle a constructor that fails?</h3></div>
<p>Throw an exception.  See <a href="exceptions.html#faq-17.2" title="[17.2] How can I handle a constructor that fails?">[17.2]</a> for details.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-10.17"></a>
<div class=FaqTitle><h3>[10.17] What is the &quot;Named Parameter Idiom&quot;?</h3></div>
<p>It's a fairly useful way to exploit <a href="references.html#faq-8.4" title="[8.4] What does object.method1().method2() mean?">method
chaining<!--rawtext:[8.4]:rawtext--></a>.
<p>The fundamental problem solved by the Named Parameter Idiom is that C++ only
supports <em>positional parameters</em>.  For example, a caller of a function
isn't allowed to say, &quot;Here's the value for formal parameter <tt>xyz</tt>, and
this other thing is the value for formal parameter <tt>pqr</tt>.&quot; All you can
do in C++ (and C and Java) is say, &quot;Here's the first parameter, here's the
second parameter, etc.&quot; The alternative, called <em>named parameters</em> and
implemented in the language Ada, is especially useful if a function takes a
large number of mostly default-able parameters.
<p>Over the years people have cooked up lots of workarounds for the lack of named
parameters in C and C++.  One of these involves burying the parameter values
in a string parameter then parsing this string at run-time.  This is what's
done in the second parameter of <nobr><tt>fopen()</tt></nobr>, for example.  Another
workaround is to combine all the boolean parameters in a bit-map, then the
caller <em>or</em>'s a bunch of bit-shifted constants together to produce the
actual parameter.  This is what's done in the second parameter of
<nobr><tt>open()</tt></nobr>, for example.  These approaches work, but the following
technique produces caller-code that's more obvious, easier to write, easier to
read, and is generally more elegant.
<p>The idea, called the Named Parameter Idiom, is to change the function's
parameters to methods of a newly created class, where all these methods return
<nobr><tt>*this</tt></nobr> by reference.  Then you simply rename the main function into a
parameterless &quot;do-it&quot; method on that class.
<p>We'll work an example to make the previous paragraph easier to understand.
<p>The example will be for the &quot;open a file&quot; concept.  Let's say that concept
logically requires a parameter for the file's name, and optionally allows
parameters for whether the file should be opened read-only <em>vs.</em> read-write
<em>vs.</em> write-only, whether or not the file should be created if it doesn't
already exist, whether the writing location should be at the end (&quot;append&quot;) or
the beginning (&quot;overwrite&quot;), the block-size if the file is to be created,
whether the I/O is buffered or non-buffered, the buffer-size, whether it is to
be shared <em>vs.</em> exclusive access, and probably a few others.  If we implemented
this concept using a normal function with positional parameters, the caller
code would be very difficult to read: there'd be as many as 8 positional
parameters, and the caller would probably make a lot of mistakes.  So instead
we use the Named Parameter Idiom.
<p>Before we go through the implementation, here's what the caller code might
look like, assuming you are willing to accept all the function's default
parameters:
<p><div class=CodeBlock>
<tt>
&nbsp;File&nbsp;f&nbsp;=&nbsp;OpenFile(&quot;foo.txt&quot;);
</tt>
</div>
<p>That's the easy case.  Now here's what it might look like if you want to
change a bunch of the parameters.
<p><div class=CodeBlock>
<tt>
&nbsp;File&nbsp;f&nbsp;=&nbsp;OpenFile(&quot;foo.txt&quot;).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;readonly().<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createIfNotExist().<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appendWhenWriting().<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockSize(1024).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unbuffered().<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exclusiveAccess();
</tt>
</div>
<p>Notice how the &quot;parameters&quot;, if it's fair to call them that, are in random
order (they're not positional) and they all have names.  So the programmer
doesn't have to remember the order of the parameters, and the names are
(hopefully) obvious.
<p>So here's how to implement it: first we create a new class (<tt>OpenFile</tt>)
that houses all the parameter values as <tt>private</tt> data members.  Then all the
methods (<nobr><tt>readonly()</tt></nobr>, <nobr><tt>blockSize(unsigned)</tt></nobr>, etc.) return
<nobr><tt>*this</tt></nobr> (that is, they return a reference to the <tt>OpenFile</tt>
object, allowing the method calls to be <a href="references.html#faq-8.4" title="[8.4] What does object.method1().method2() mean?">chained<!--rawtext:[8.4]:rawtext--></a>.
Finally we make the required parameter (the file's name, in this case) into a
normal, positional, parameter on <tt>OpenFile</tt>'s constructor.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;File;<br>
&nbsp;<br>
&nbsp;class&nbsp;OpenFile&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;OpenFile(const&nbsp;string&amp;&nbsp;filename);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;sets&nbsp;all&nbsp;the&nbsp;default&nbsp;values&nbsp;for&nbsp;each&nbsp;data&nbsp;member</em><tt><br>
&nbsp;&nbsp;&nbsp;OpenFile&amp;&nbsp;readonly();&nbsp;&nbsp;</tt><em>//&nbsp;changes&nbsp;<tt>readonly_</tt>&nbsp;to&nbsp;<tt>true</tt></em><tt><br>
&nbsp;&nbsp;&nbsp;OpenFile&amp;&nbsp;createIfNotExist();<br>
&nbsp;&nbsp;&nbsp;OpenFile&amp;&nbsp;blockSize(unsigned&nbsp;nbytes);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;File;<br>
&nbsp;&nbsp;&nbsp;bool&nbsp;readonly_;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;defaults&nbsp;to&nbsp;<tt>false</tt>&nbsp;[for&nbsp;example]</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;unsigned&nbsp;blockSize_;&nbsp;&nbsp;</tt><em>//&nbsp;defaults&nbsp;to&nbsp;4096&nbsp;[for&nbsp;example]</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};
</tt>
</div>
<p>The only other thing to do is make the constructor for class <tt>File</tt> to
take an <tt>OpenFile</tt> object:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;File&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;File(const&nbsp;OpenFile&amp;&nbsp;params);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;vacuums&nbsp;the&nbsp;actual&nbsp;params&nbsp;out&nbsp;of&nbsp;the&nbsp;OpenFile&nbsp;object</em><tt><br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};
</tt>
</div>
<p>Note that <tt>OpenFile</tt> declares <tt>File</tt> as its <a href="friends.html" title="[14] Friends"><tt>friend</tt><!--rawtext:[14]:rawtext--></a>, that way <a href="friends.html#faq-14.2" title="[14.2] Do friends violate encapsulation?"><tt>OpenFile</tt>
doesn't need a bunch of (otherwise useless) <nobr><tt>public:</tt></nobr> <em>get</em>
methods<!--rawtext:[14.2]:rawtext--></a>.
<p>Since each member function in the chain returns a reference, there is no
copying of objects and the chain is highly efficient.  Furthermore, if the
various member functions are <tt>inline</tt>, the generated object code will probably
be on par with C-style code that sets various members of a <tt>struct</tt>.  Of
course if the member functions are not <tt>inline</tt>, there may be a slight
increase in code size and a slight decrease in performance (but only if the
construction occurs on the critical path of a CPU-bound program; this is a can
of worms I'll try to avoid opening; read <a href="faq-book.html#faq-3.1" title="[3.1] Is there a C++ FAQ Book in addition to the C++ FAQ Lite?">the C++ FAQs
book<!--rawtext:[3.1]:rawtext--></a> for a rather thorough discussion of the issues), so it may, in this
case, be a tradeoff for making the code more reliable.
<p><small>[&nbsp;<a href="#top" title="Top of section [10] Constructors">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [10] Constructors">Bottom</a> |&nbsp;<a href="inline-functions.html" title="[9] Inline functions">Previous&nbsp;section</a> |&nbsp;<a href="dtors.html" title="[11] Destructors">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="bottom"></a>
<a href="mailto:cline@parashift.com" title="cline@parashift.com"><img src="mbox.gif" height=26 width=89 alt="E-Mail">&nbsp;E-mail the author</a><br>
[&nbsp;<a href="index.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>
|&nbsp;<a href="index.html#table-of-contents" title="Table of contents">Table&nbsp;of&nbsp;contents</a>
|&nbsp;<a href="subject-index.html" title="Subject index; 3706 links to 2361 topics">Subject&nbsp;index</a>
|&nbsp;<a href="copy-permissions.html#faq-1.1" title="[1.1] Author">About&nbsp;the&nbsp;author</a>
|&nbsp;<a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">&copy;</a>
|&nbsp;<a href="on-line-availability.html#faq-2.2" title="[2.2] How can I get a copy of all the HTML files of C++ FAQ Lite so I can read them Off-Line?">Download&nbsp;your&nbsp;own&nbsp;copy</a>&nbsp;]<br>
<small>Revised May 2, 2003</small>
</body>
</html>
