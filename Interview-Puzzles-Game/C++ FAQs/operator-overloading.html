<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
	"http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<title>[13] Operator overloading, C++ FAQ Lite</title>
<meta name="FILENAME" content="operator-overloading.html">
<meta name="ABSTRACT" content="[13] Operator overloading, C++ FAQ Lite">
<meta name="OWNER"    content="cline@parashift.com">
<meta name="AUTHOR"   content="Marshall Cline, cline@parashift.com">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rev=made href="mailto:cline@parashift.com">
<style type='text/css'>
  <!--
  body       { font-family: arial; color: black; background: white }
  .CodeBlock { color: black; background-color: #dfdfdf; margin-left: 30px; margin-right: 30px; padding: 5pt }
  .FaqTitle  { color: black; background-color: gold }
  .Updated   { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #ffff00; border: solid #e0e000 1px; }
  .New       { color: black; cursor: default; font-size: x-small; font-variant: small-caps; font-family: cursive;
               background-color: #00ff00; border: solid #00d000 1px; }
  ul         { margin-bottom: 1px; margin-top: 1px }
  ol         { margin-bottom: 1px; margin-top: 1px }
  li         { margin-bottom: 4px; margin-top: 4px }
  a          { color: blue }
  a:hover    { color: red }
  -->
</style>
</head>
<body>
<h1><a name="top"></a>[13] Operator overloading<br>
<small><small>(Part of <a href="index.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>, <a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">Copyright&nbsp;&copy; 1991-2003</a>, <a href="http://www.parashift.com/" title="www.parashift.com/" target='_blank'>Marshall Cline</a>, <a href="mailto:cline@parashift.com" title="cline@parashift.com"><tt>cline@parashift.com</tt></a>)</small></small></h1>
<hr>
<h3>FAQs in section [13]:</h3>
<ul>
<li><a href="operator-overloading.html#faq-13.1" title="[13.1] What's the deal with operator overloading?">[13.1] What's the deal with <tt>operator</tt> overloading?</a></li>
<li><a href="operator-overloading.html#faq-13.2" title="[13.2] What are the benefits of operator overloading?">[13.2] What are the benefits of operator overloading?</a></li>
<li><a href="operator-overloading.html#faq-13.3" title="[13.3] What are some examples of operator overloading?">[13.3] What are some examples of operator overloading?</a></li>
<li><a href="operator-overloading.html#faq-13.4" title="[13.4] But operator overloading makes my class look ugly; isn't it supposed to make my code clearer?">[13.4] But <tt>operator</tt> overloading makes my class look ugly; isn't it supposed to make my code clearer?</a></li>
<li><a href="operator-overloading.html#faq-13.5" title="[13.5] What operators can/cannot be overloaded?">[13.5] What operators can/cannot be overloaded?</a></li>
<li><a href="operator-overloading.html#faq-13.6" title="[13.6] Can I overload operator== so it lets me compare two char[] using a string comparison?">[13.6] Can I overload <nobr><tt>operator==</tt></nobr> so it lets me compare two <nobr><tt>char[]</tt></nobr> using a string comparison?</a></li>
<li><a href="operator-overloading.html#faq-13.7" title="[13.7] Can I create a operator** for &quot;to-the-power-of&quot; operations?">[13.7] Can I create a <nobr><tt>operator**</tt></nobr> for &quot;to-the-power-of&quot; operations?</a></li>
<li><a href="operator-overloading.html#faq-13.8" title="[13.8] How do I create a subscript operator for a Matrix class?">[13.8] How do I create a subscript <tt>operator</tt> for a <tt>Matrix</tt> class?</a></li>
<li><a href="operator-overloading.html#faq-13.9" title="[13.9] Why shouldn't my Matrix class's interface look like an array-of-array?">[13.9] Why shouldn't my <tt>Matrix</tt> class's interface look like an array-of-array?</a></li>
<li><a href="operator-overloading.html#faq-13.10" title="[13.10] Should I design my classes from the outside (interfaces first) or from the inside (data first)?">[13.10] Should I design my classes from the outside (interfaces first) or from the inside (data first)?</a></li>
<li><a href="operator-overloading.html#faq-13.11" title="[13.11] How can I overload the prefix and postfix forms of operators ++ and --?">[13.11] How can I overload the prefix and postfix forms of operators <nobr><tt>++</tt></nobr> and <nobr><tt>--</tt></nobr>?</a></li>
<li><a href="operator-overloading.html#faq-13.12" title="[13.12] Which is more efficient: i++ or ++i?">[13.12] Which is more efficient: <nobr><tt>i++</tt></nobr> or <nobr><tt>++i</tt></nobr>?</a></li>
</ul>
<p><hr>
<p><a name="faq-13.1"></a>
<div class=FaqTitle><h3>[13.1] What's the deal with <tt>operator</tt> overloading?</h3></div>
<p>It allows you to provide an intuitive interface to users of your class, plus
makes it possible for <a href="containers-and-templates.html#faq-34.6" title="[34.6] What's the idea behind templates?">templates<!--rawtext:[34.6]:rawtext--></a> to work equally
well with classes and built-in/intrinsic types.
<p>Operator overloading allows C/C++ operators to have user-defined meanings on
user-defined types (classes).  Overloaded operators are syntactic sugar for
function calls:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Fred&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;#if&nbsp;0<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Without&nbsp;<tt>operator</tt>&nbsp;overloading:</em><tt><br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;add(const&nbsp;Fred&amp;&nbsp;x,&nbsp;const&nbsp;Fred&amp;&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;mul(const&nbsp;Fred&amp;&nbsp;x,&nbsp;const&nbsp;Fred&amp;&nbsp;y);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;f(const&nbsp;Fred&amp;&nbsp;a,&nbsp;const&nbsp;Fred&amp;&nbsp;b,&nbsp;const&nbsp;Fred&amp;&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;add(add(mul(a,b),&nbsp;mul(b,c)),&nbsp;mul(c,a));&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Yuk...</em><tt><br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;#else<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;With&nbsp;<tt>operator</tt>&nbsp;overloading:</em><tt><br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;operator+&nbsp;(const&nbsp;Fred&amp;&nbsp;x,&nbsp;const&nbsp;Fred&amp;&nbsp;y);<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;operator*&nbsp;(const&nbsp;Fred&amp;&nbsp;x,&nbsp;const&nbsp;Fred&amp;&nbsp;y);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Fred&nbsp;f(const&nbsp;Fred&amp;&nbsp;a,&nbsp;const&nbsp;Fred&amp;&nbsp;b,&nbsp;const&nbsp;Fred&amp;&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a*b&nbsp;+&nbsp;b*c&nbsp;+&nbsp;c*a;<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;<br>
&nbsp;#endif
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.2"></a>
<div class=FaqTitle><h3>[13.2] What are the benefits of operator overloading?</h3></div>
<p>By overloading standard operators on a class, you can exploit the intuition of
the users of that class.  This lets users program in the language of the
problem domain rather than in the language of the machine.
<p>The ultimate goal is to reduce both the learning curve and the defect rate.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.3"></a>
<div class=FaqTitle><h3>[13.3] What are some examples of operator overloading?</h3></div>
<p>Here are a few of the many examples of operator overloading:
<ul>
<li><nobr><tt>myString + yourString</tt></nobr> might concatenate two <nobr><tt>std::string</tt></nobr>
objects</li>
<li><nobr><tt>myDate++</tt></nobr> might increment a <tt>Date</tt> object</li>
<li><nobr><tt>a * b</tt></nobr> might multiply two <tt>Number</tt> objects</li>
<li><nobr><tt>a[i]</tt></nobr> might access an element of an <tt>Array</tt> object</li>
<li><nobr><tt>x = *p</tt></nobr> might dereference a &quot;smart pointer&quot; that &quot;points&quot; to
a disk record &#151; it could seek to the location on disk where <tt>p</tt> &quot;points&quot; and
return the appropriate record into <tt>x</tt></li>
</ul>
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.4"></a>
<div class=FaqTitle><h3>[13.4] But <tt>operator</tt> overloading makes my class look ugly; isn't it supposed to make my code clearer?</h3></div>
<p>Operator overloading <a href="operator-overloading.html#faq-13.2" title="[13.2] What are the benefits of operator overloading?">makes life easier for the
<em>users</em> of a class<!--rawtext:[13.2]:rawtext--></a>, not for the developer of the class!
<p>Consider the following example.
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Array&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;int&amp;&nbsp;operator[]&nbsp;(unsigned&nbsp;i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Some&nbsp;people&nbsp;don't&nbsp;like&nbsp;this&nbsp;syntax</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;int&amp;&nbsp;Array::operator[]&nbsp;(unsigned&nbsp;i)&nbsp;&nbsp;</tt><em>//&nbsp;Some&nbsp;people&nbsp;don't&nbsp;like&nbsp;this&nbsp;syntax</em><tt><br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>Some people don't like the keyword <tt>operator</tt> or the somewhat funny
syntax that goes with it in the body of the class itself.  But the <tt>operator</tt>
overloading syntax isn't supposed to make life easier for the <em>developer</em>
of a class.  It's supposed to make life easier for the <em>users</em> of the
class:
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Array&nbsp;a;<br>
&nbsp;&nbsp;&nbsp;a[3]&nbsp;=&nbsp;4;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;User&nbsp;code&nbsp;should&nbsp;be&nbsp;obvious&nbsp;and&nbsp;easy&nbsp;to&nbsp;understand...</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>Remember: in a reuse-oriented world, there will usually be many people who use
your class, but there is only one person who builds it (yourself); therefore
you should do things that favor the many rather than the few.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.5"></a>
<div class=FaqTitle><h3>[13.5] What operators can/cannot be overloaded?</h3></div>
<p>Most can be overloaded. The only C operators that can't be are <tt>.</tt> and <nobr><tt>?:</tt></nobr>
(and <tt>sizeof</tt>, which is technically an operator).  C++ adds a few of its own
operators, most of which can be overloaded except <nobr><tt>::</tt></nobr> and <nobr><tt>.*</tt></nobr>.
<p>Here's an example of the subscript <tt>operator</tt> (it returns a reference).  First
with<em>out</em> <tt>operator</tt> overloading:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Array&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;int&amp;&nbsp;elem(unsigned&nbsp;i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;if&nbsp;(i&nbsp;&gt;&nbsp;99)&nbsp;error();&nbsp;return&nbsp;data[i];&nbsp;}<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;int&nbsp;data[100];<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Array&nbsp;a;<br>
&nbsp;&nbsp;&nbsp;a.elem(10)&nbsp;=&nbsp;42;<br>
&nbsp;&nbsp;&nbsp;a.elem(12)&nbsp;+=&nbsp;a.elem(13);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p>Now the same logic is presented <em>with</em> operator overloading:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Array&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;int&amp;&nbsp;operator[]&nbsp;(unsigned&nbsp;i)&nbsp;{&nbsp;if&nbsp;(i&nbsp;&gt;&nbsp;99)&nbsp;error();&nbsp;return&nbsp;data[i];&nbsp;}<br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;int&nbsp;data[100];<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Array&nbsp;a;<br>
&nbsp;&nbsp;&nbsp;a[10]&nbsp;=&nbsp;42;<br>
&nbsp;&nbsp;&nbsp;a[12]&nbsp;+=&nbsp;a[13];<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.6"></a>
<div class=FaqTitle><h3>[13.6] Can I overload <nobr><tt>operator==</tt></nobr> so it lets me compare two <nobr><tt>char[]</tt></nobr> using a string comparison?</h3></div>
<p>No: <a href="intrinsic-types.html#faq-26.10" title="[26.10] Can I define an operator overload that works with built-in / intrinsic / primitive types?">at least one operand of any
overloaded <tt>operator</tt> must be of some user-defined type<!--rawtext:[26.10]:rawtext--></a> (most of the
time that means a <tt>class</tt>).
<p>But even if C++ allowed you to do this, which it doesn't, you wouldn't want to
do it anyway since you really should be using a <a href="exceptions.html#faq-17.5" title="[17.5] How do I change the string-length of an array of char to prevent memory leaks even if/when someone throws an exception?"><nobr><tt>std::string</tt></nobr>-like class rather than an array of <tt>char</tt> in the first place<!--rawtext:[17.5]:rawtext--></a>
since <a href="containers-and-templates.html#faq-34.1" title="[34.1] Why should I use container classes rather than simple arrays?">arrays are evil<!--rawtext:[34.1]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.7"></a>
<div class=FaqTitle><h3>[13.7] Can I create a <nobr><tt>operator**</tt></nobr> for &quot;to-the-power-of&quot; operations?</h3></div>
<p>Nope.
<p>The names of, precedence of, associativity of, and arity of operators is fixed
by the language.  There is no <nobr><tt>operator**</tt></nobr> in C++, so you cannot create one for
a <tt>class</tt> type.
<p>If you're in doubt, consider that <nobr><tt>x ** y</tt></nobr> is the same as <nobr><tt>x *
(*y)</tt></nobr> (in other words, the compiler assumes <tt>y</tt> is a pointer).  Besides,
<tt>operator</tt> overloading is just syntactic sugar for function calls.  Although
this particular syntactic sugar can be very sweet, it doesn't add anything
fundamental.  I suggest you overload <nobr><tt>pow(base,exponent)</tt></nobr> (a double
precision version is in <nobr><tt>&lt;cmath&gt;</tt></nobr>).
<p>By the way, <nobr><tt>operator^</tt></nobr> can work for to-the-power-of, except it has the wrong
precedence and associativity.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.8"></a>
<div class=FaqTitle><h3>[13.8] How do I create a subscript <tt>operator</tt> for a <tt>Matrix</tt> class?</h3></div>
<p>Use <nobr><tt>operator()</tt></nobr> rather than <nobr><tt>operator[]</tt></nobr>.
<p>When you have multiple subscripts, the cleanest way to do it is with
<nobr><tt>operator()</tt></nobr> rather than with <nobr><tt>operator[]</tt></nobr>.  The reason is that
<nobr><tt>operator[]</tt></nobr> always takes exactly one parameter, but <nobr><tt>operator()</tt></nobr>
can take any number of parameters (in the case of a rectangular matrix, two
paramters are needed).
<p>For example:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Matrix&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Matrix(unsigned&nbsp;rows,&nbsp;unsigned&nbsp;cols);<br>
&nbsp;&nbsp;&nbsp;double&amp;&nbsp;operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col);<br>
&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;~Matrix();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Destructor</em><tt><br>
&nbsp;&nbsp;&nbsp;Matrix(const&nbsp;Matrix&amp;&nbsp;m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Copy&nbsp;constructor</em><tt><br>
&nbsp;&nbsp;&nbsp;Matrix&amp;&nbsp;operator=&nbsp;(const&nbsp;Matrix&amp;&nbsp;m);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Assignment&nbsp;operator</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;unsigned&nbsp;rows_,&nbsp;cols_;<br>
&nbsp;&nbsp;&nbsp;double*&nbsp;data_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;Matrix::Matrix(unsigned&nbsp;rows,&nbsp;unsigned&nbsp;cols)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;rows_&nbsp;(rows),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cols_&nbsp;(cols),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_&nbsp;(new&nbsp;double[rows&nbsp;*&nbsp;cols])<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(rows&nbsp;==&nbsp;0&nbsp;||&nbsp;cols&nbsp;==&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;BadIndex(&quot;Matrix&nbsp;constructor&nbsp;has&nbsp;0&nbsp;size&quot;);<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;Matrix::~Matrix()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;delete[]&nbsp;data_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;double&amp;&nbsp;Matrix::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;rows_&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;cols_)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;BadIndex(&quot;Matrix&nbsp;subscript&nbsp;out&nbsp;of&nbsp;bounds&quot;);<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[cols_*row&nbsp;+&nbsp;col];<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline<br>
&nbsp;double&nbsp;Matrix::operator()&nbsp;(unsigned&nbsp;row,&nbsp;unsigned&nbsp;col)&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;if&nbsp;(row&nbsp;&gt;=&nbsp;rows_&nbsp;||&nbsp;col&nbsp;&gt;=&nbsp;cols_)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;BadIndex(&quot;const&nbsp;Matrix&nbsp;subscript&nbsp;out&nbsp;of&nbsp;bounds&quot;);<br>
&nbsp;&nbsp;&nbsp;return&nbsp;data_[cols_*row&nbsp;+&nbsp;col];<br>
&nbsp;}
</tt>
</div>
<p>Then you can access an element of <tt>Matrix</tt> <tt>m</tt> using <nobr><tt>m(i,j)</tt></nobr>
rather than <nobr><tt>m[i][j]</tt></nobr>:
<p><div class=CodeBlock>
<tt>
&nbsp;int&nbsp;main()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Matrix&nbsp;m(10,10);<br>
&nbsp;&nbsp;&nbsp;m(5,8)&nbsp;=&nbsp;106.15;<br>
&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;m(5,8);<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;}
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.9"></a>
<div class=FaqTitle><h3>[13.9] Why shouldn't my <tt>Matrix</tt> class's interface look like an array-of-array?</h3></div>
<p>Here's what this FAQ is really all about: Some people build a Matrix class that
has an <nobr><tt>operator[]</tt></nobr> that returns a reference to an <tt>Array</tt> object,
and that <tt>Array</tt> object has an <nobr><tt>operator[]</tt></nobr> that returns an element
of the Matrix (e.g., a reference to a <tt>double</tt>).  Thus they access
elements of the matrix using syntax like <nobr><tt>m[i][j]</tt></nobr> rather than
<a href="operator-overloading.html#faq-13.8" title="[13.8] How do I create a subscript operator for a Matrix class?">syntax like <nobr><tt>m(i,j)</tt></nobr><!--rawtext:[13.8]:rawtext--></a>.
<p>The array-of-array solution obviously works, but it is less flexible than
<a href="operator-overloading.html#faq-13.8" title="[13.8] How do I create a subscript operator for a Matrix class?">the <nobr><tt>operator()</tt></nobr> approach<!--rawtext:[13.8]:rawtext--></a>.  Specifically,
there are easy performance tuning tricks that can be done with the
<nobr><tt>operator()</tt></nobr> approach that are more difficult in the <nobr><tt>[][]</tt></nobr>
approach, and therefore the <nobr><tt>[][]</tt></nobr> approach is more likely to lead to bad
performance, at least in some cases.
<p>For example, the easiest way to implement the <nobr><tt>[][]</tt></nobr> approach is to use a
physical layout of the matrix as a dense matrix that is stored in row-major
form (or is it column-major; I can't ever remember).  In contrast,
<a href="operator-overloading.html#faq-13.8" title="[13.8] How do I create a subscript operator for a Matrix class?">the <nobr><tt>operator()</tt></nobr> approach<!--rawtext:[13.8]:rawtext--></a> totally hides
the physical layout of the matrix, and that can lead to better performance in
some cases.
<p>Put it this way: the <nobr><tt>operator()</tt></nobr> approach is never worse than, and
sometimes better than, the <nobr><tt>[][]</tt></nobr> approach.
<ul>
<li>The <nobr><tt>operator()</tt></nobr> approach is never worse because it is easy to
implement the dense, row-major physical layout using the <nobr><tt>operator()</tt></nobr>
approach, so when that configuration happens to be the optimal layout from a
performance standpoint, the <nobr><tt>operator()</tt></nobr> approach is just as easy as the
<nobr><tt>[][]</tt></nobr> approach (perhaps the <nobr><tt>operator()</tt></nobr> approach is a tiny bit
easier, but I won't quibble over minor nits).</li>
<li>The <nobr><tt>operator()</tt></nobr> approach is sometimes better because whenever the
optimal layout for a given application happens to be something other than
dense, row-major, the implementation is often significantly easier using the
<nobr><tt>operator()</tt></nobr> approach compared to the <nobr><tt>[][]</tt></nobr> approach.</li>
</ul>
<p>As an example of when a physical layout makes a significant difference, a
recent project happened to access the matrix elements in columns (that is, the
algorithm accesses all the elements in one column, then the elements in
another, etc.), and if the physical layout is row-major, the accesses can
&quot;stride the cache&quot;.  For example, if the rows happen to be almost as big as the
processor's cache size, the machine can end up with a &quot;cache miss&quot; for almost
every element access.  In this particular project, we got a 20% improvement in
performance by changing the mapping from the logical layout (row,column) to the
physical layout (column,row).
<p>Of course there are many examples of this sort of thing from numerical methods,
and sparse matrices are a whole other dimension on this issue.  Since it is, in
general, easier to implement a sparse matrix or swap row/column ordering using
the <nobr><tt>operator()</tt></nobr> approach, the <nobr><tt>operator()</tt></nobr> approach loses nothing
and may gain something &#151; it has no down-side and a potential up-side.
<p>Use <a href="operator-overloading.html#faq-13.8" title="[13.8] How do I create a subscript operator for a Matrix class?">the <nobr><tt>operator()</tt></nobr> approach<!--rawtext:[13.8]:rawtext--></a>.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.10"></a>
<div class=FaqTitle><h3>[13.10] Should I design my classes from the outside (interfaces first) or from the inside (data first)?</h3></div>
<p>From the outside!
<p>A good interface provides a <a href="classes-and-objects.html#faq-7.3" title="[7.3] When is an interface &quot;good&quot;?"><em>simplified</em> view that
is expressed in the <em>vocabulary of a user</em><!--rawtext:[7.3]:rawtext--></a>.  In the case of OO
software, the interface is normally the set of public methods of either a
single class or a <a href="friends.html#faq-14.2" title="[14.2] Do friends violate encapsulation?">tight group of classes<!--rawtext:[14.2]:rawtext--></a>.
<p>First think about what the object logically represents, not how you intend to
physically build it.  For example, suppose you have a <tt>Stack</tt> class that will
be built by containing a <tt>LinkedList</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Stack&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;LinkedList&nbsp;list_;<br>
&nbsp;};
</tt>
</div>
<p>Should the Stack have a <nobr><tt>get()</tt></nobr> method that returns the <tt>LinkedList</tt>?  Or a
<nobr><tt>set()</tt></nobr> method that takes a <tt>LinkedList</tt>?  Or a constructor that takes a
<tt>LinkedList</tt>?  Obviously the answer is <em>No,</em> since you should design your
interfaces from the outside-in.  I.e., users of <tt>Stack</tt> objects don't care
about <tt>LinkedList</tt>s; they care about pushing and popping.
<p>Now for another example that is a bit more subtle.  Suppose class <tt>LinkedList</tt>
is built using a linked list of <tt>Node</tt> objects, where each <tt>Node</tt> object has a
pointer to the next <tt>Node</tt>:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Node&nbsp;{&nbsp;</tt><em>/*...*/</em><tt>&nbsp;};<br>
&nbsp;<br>
&nbsp;class&nbsp;LinkedList&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;Node*&nbsp;first_;<br>
&nbsp;};
</tt>
</div>
<p>Should the <tt>LinkedList</tt> class have a <nobr><tt>get()</tt></nobr> method that will let users access
the first <tt>Node</tt>?  Should the <tt>Node</tt> object have a <nobr><tt>get()</tt></nobr> method that will let
users follow that <tt>Node</tt> to the next <tt>Node</tt> in the chain?  In other words, what
should a <tt>LinkedList</tt> look like from the outside?  Is a <tt>LinkedList</tt> really a
chain of <tt>Node</tt> objects?  Or is that just an implementation detail?  And if it
is just an implementation detail, how will the <tt>LinkedList</tt> let users access
each of the elements in the <tt>LinkedList</tt> one at a time?
<p>The key insight is the realization that a <tt>LinkedList</tt> is <em>not</em> a chain
of <tt>Node</tt>s.  That may be <em>how</em> it is built, but that is not <em>what</em>
it is.  What it is is a sequence of elements.  Therefore the <tt>LinkedList</tt>
abstraction should provide a &quot;LinkedListIterator&quot; <tt>class</tt> as well, and that
&quot;LinkedListIterator&quot; might have an <nobr><tt>operator++</tt></nobr> to go to the next
element, and it might have a <nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> pair to access its <em>value</em>
stored in the <tt>Node</tt> (the value in the <tt>Node</tt> element is solely the
responsibility of the <tt>LinkedList</tt> user, which is why there is a
<nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> pair that allows the user to freely manipulate that value).
<p>Starting from the user's perspective, we might want our <tt>LinkedList</tt> <tt>class</tt> to
support operations that look similar to accessing an array using pointer
arithmetic:
<p><div class=CodeBlock>
<tt>
&nbsp;void&nbsp;userCode(LinkedList&amp;&nbsp;a)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;for&nbsp;(LinkedListIterator&nbsp;p&nbsp;=&nbsp;a.begin();&nbsp;p&nbsp;!=&nbsp;a.end();&nbsp;++p)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::cout&nbsp;&lt;&lt;&nbsp;*p&nbsp;&lt;&lt;&nbsp;'\n';<br>
&nbsp;}
</tt>
</div>
<p>To implement this interface, <tt>LinkedList</tt> will need a <nobr><tt>begin()</tt></nobr> method and an
<nobr><tt>end()</tt></nobr> method.  These return a &quot;LinkedListIterator&quot; object.  The
&quot;LinkedListIterator&quot; will need a method to go forward, <nobr><tt>++p</tt></nobr>; a method to
access the current element, <nobr><tt>*p</tt></nobr>; and a comparison operator, <nobr><tt>p !=
a.end()</tt></nobr>.
<p>The code follows.  The important thing to notice is that <tt>LinkedList</tt> does
<em>not</em> have any methods that let users access <tt>Node</tt>s.  <tt>Node</tt>s are an
implementation technique that is <em>completely</em> buried.  This makes the
<tt>LinkedList</tt> class safer (no chance a user will mess up the invariants and
linkages between the various nodes), easier to use (users don't need to expend
extra effort keeping the node-count equal to the actual number of nodes, or
any other infrastructure stuff), and more flexible (by changing a single
<tt>typedef</tt>, users could change their code from using <tt>LinkedList</tt> to some
other list-like class and the bulk of their code would compile cleanly and
hopefully with improved performance characteristics).
<p><div class=CodeBlock>
<tt>
&nbsp;#include&nbsp;&lt;cassert&gt;&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Poor&nbsp;man's&nbsp;exception&nbsp;handling</em><tt><br>
&nbsp;<br>
&nbsp;class&nbsp;LinkedListIterator;<br>
&nbsp;class&nbsp;LinkedList;<br>
&nbsp;<br>
&nbsp;class&nbsp;Node&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;No&nbsp;<tt>public</tt>&nbsp;members;&nbsp;this&nbsp;is&nbsp;a&nbsp;&quot;<tt>private</tt>&nbsp;<tt>class</tt>&quot;</em><tt><br>
&nbsp;&nbsp;&nbsp;friend&nbsp;LinkedListIterator;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;<a href="friends.html" title="[14] Friends">A&nbsp;friend&nbsp;class<!--rawtext:[14]:rawtext--></a></em><tt><br>
&nbsp;&nbsp;&nbsp;friend&nbsp;LinkedList;<br>
&nbsp;&nbsp;&nbsp;Node*&nbsp;next_;<br>
&nbsp;&nbsp;&nbsp;int&nbsp;elem_;<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;class&nbsp;LinkedListIterator&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;bool&nbsp;operator==&nbsp;(LinkedListIterator&nbsp;i)&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;bool&nbsp;operator!=&nbsp;(LinkedListIterator&nbsp;i)&nbsp;const;<br>
&nbsp;&nbsp;&nbsp;void&nbsp;operator++&nbsp;();&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Go&nbsp;to&nbsp;the&nbsp;next&nbsp;element</em><tt><br>
&nbsp;&nbsp;&nbsp;int&amp;&nbsp;operator*&nbsp;&nbsp;();&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Access&nbsp;the&nbsp;current&nbsp;element</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;LinkedListIterator(Node*&nbsp;p);<br>
&nbsp;&nbsp;&nbsp;Node*&nbsp;p_;<br>
&nbsp;&nbsp;&nbsp;friend&nbsp;LinkedList;&nbsp;&nbsp;</tt><em>//&nbsp;so&nbsp;LinkedList&nbsp;can&nbsp;construct&nbsp;a&nbsp;LinkedListIterator</em><tt><br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;class&nbsp;LinkedList&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;void&nbsp;append(int&nbsp;elem);&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Adds&nbsp;<tt>elem</tt>&nbsp;after&nbsp;the&nbsp;end</em><tt><br>
&nbsp;&nbsp;&nbsp;void&nbsp;prepend(int&nbsp;elem);&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;Adds&nbsp;<tt>elem</tt>&nbsp;before&nbsp;the&nbsp;beginning</em><tt><br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;LinkedListIterator&nbsp;begin();<br>
&nbsp;&nbsp;&nbsp;LinkedListIterator&nbsp;end();<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;Node*&nbsp;first_;<br>
&nbsp;};
</tt>
</div>
<p>Here are the methods that are obviously inlinable (probably in the same header
file):
<p><div class=CodeBlock>
<tt>
&nbsp;inline&nbsp;bool&nbsp;LinkedListIterator::operator==&nbsp;(LinkedListIterator&nbsp;i)&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return&nbsp;p_&nbsp;==&nbsp;i.p_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;bool&nbsp;LinkedListIterator::operator!=&nbsp;(LinkedListIterator&nbsp;i)&nbsp;const<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return&nbsp;p_&nbsp;!=&nbsp;i.p_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;void&nbsp;LinkedListIterator::operator++()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;assert(p_&nbsp;!=&nbsp;NULL);&nbsp;&nbsp;</tt><em>//&nbsp;or&nbsp;<nobr><tt>if&nbsp;(p_==NULL)&nbsp;throw&nbsp;</tt>...<tt></tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;p_&nbsp;=&nbsp;p_-&gt;next_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;int&amp;&nbsp;LinkedListIterator::operator*()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;assert(p_&nbsp;!=&nbsp;NULL);&nbsp;&nbsp;</tt><em>//&nbsp;or&nbsp;<nobr><tt>if&nbsp;(p_==NULL)&nbsp;throw&nbsp;</tt>...<tt></tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;p_-&gt;elem_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;LinkedListIterator::LinkedListIterator(Node*&nbsp;p)<br>
&nbsp;&nbsp;&nbsp;:&nbsp;p_(p)<br>
&nbsp;{&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;LinkedListIterator&nbsp;LinkedList::begin()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return&nbsp;first_;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;inline&nbsp;LinkedListIterator&nbsp;LinkedList::end()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;return&nbsp;NULL;<br>
&nbsp;}
</tt>
</div>
<p>Conclusion: The linked list had two different kinds of data.  The values of the
elements stored in the linked list are the responsibility of the user of the
linked list (and <em>only</em> the user; the linked list itself makes no attempt
to prohibit users from changing the third element to 5), and the linked list's
infrastructure data (<tt>next</tt> pointers, etc.), whose values are the
responsibility of the linked list (and <em>only</em> the linked list; e.g., the
linked list does not let users change (or even look at!) the various
<tt>next</tt> pointers).
<p>Thus the only <nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> methods were to get and set the <em>elements</em>
of the linked list, but not the infrastructure of the linked list.  Since the
linked list hides the infrastructure pointers/etc., it is able to make very
strong promises regarding that infrastructure (e.g., if it was a doubly linked
list, it might guarantee that every forward pointer was matched by a backwards
pointer from the next <tt>Node</tt>).
<p>So, we see here an example of where the values of <em>some</em> of a class's
data is the responsibility of <em>users</em> (in which case the class needs to
have <nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> methods for that data) but the data that the class wants
to control does not necessarily have <nobr><tt>get()</tt></nobr>/<nobr><tt>set()</tt></nobr> methods.
<p>Note: the purpose of this example is <em>not</em> to show you how to write a
linked-list class.  In fact you should <em>not</em> &quot;roll your own&quot; linked-list
class since you should use one of the &quot;container classes&quot; provided with your
compiler.  Ideally you'll use one of the <a href="class-libraries.html#faq-36.1" title="[36.1] What is the &quot;STL&quot;?">standard container
classes<!--rawtext:[36.1]:rawtext--></a> such as the <nobr><tt>std::list&lt;T&gt;</tt></nobr> template.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.11"></a>
<div class=FaqTitle><h3>[13.11] How can I overload the prefix and postfix forms of operators <nobr><tt>++</tt></nobr> and <nobr><tt>--</tt></nobr>?</h3></div>
<p>Via a dummy parameter.
<p>Since the prefix and postfix <nobr><tt>++</tt></nobr> operators can have two definitions,
the C++ language gives us two different signatures.  Both are called
<nobr><tt>operator++()</tt></nobr>, but the prefix version takes no parameters and the
postfix version takes a dummy <tt>int</tt>.  (Although this discussion revolves
around the <nobr><tt>++</tt></nobr> operator, the <nobr><tt>--</tt></nobr> operator is completely
symmetric, and all the rules and guidelines that apply to one also apply to
the other.)
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Number&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Number&amp;&nbsp;operator++&nbsp;();&nbsp;&nbsp;&nbsp;&nbsp;</tt><em>//&nbsp;prefix&nbsp;++</em><tt><br>
&nbsp;&nbsp;&nbsp;Number&nbsp;&nbsp;operator++&nbsp;(int);&nbsp;</tt><em>//&nbsp;postfix&nbsp;++</em><tt><br>
&nbsp;};
</tt>
</div>
<p>Note the different return types: the prefix version returns by reference, the
postfix version by value.  If that's not immediately obvious to you, it should
be after you see the definitions (and after you remember that <nobr><tt>y = x++</tt></nobr>
and <nobr><tt>y = ++x</tt></nobr> set <tt>y</tt> to different things).
<p><div class=CodeBlock>
<tt>
&nbsp;Number&amp;&nbsp;Number::operator++&nbsp;()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;Number&nbsp;Number::operator++&nbsp;(int)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;Number&nbsp;ans&nbsp;=&nbsp;*this;<br>
&nbsp;&nbsp;&nbsp;++(*this);&nbsp;&nbsp;</tt><em>//&nbsp;or&nbsp;just&nbsp;call&nbsp;<nobr><tt>operator++()</tt></nobr></em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;ans;<br>
&nbsp;}
</tt>
</div>
<p>The other option for the postfix version is to return nothing:
<p><div class=CodeBlock>
<tt>
&nbsp;class&nbsp;Number&nbsp;{<br>
&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;Number&amp;&nbsp;operator++&nbsp;();<br>
&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;operator++&nbsp;(int);<br>
&nbsp;};<br>
&nbsp;<br>
&nbsp;Number&amp;&nbsp;Number::operator++&nbsp;()<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;</tt><em>...</em><tt><br>
&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br>
&nbsp;}<br>
&nbsp;<br>
&nbsp;void&nbsp;Number::operator++&nbsp;(int)<br>
&nbsp;{<br>
&nbsp;&nbsp;&nbsp;++(*this);&nbsp;&nbsp;</tt><em>//&nbsp;or&nbsp;just&nbsp;call&nbsp;<nobr><tt>operator++()</tt></nobr></em><tt><br>
&nbsp;}
</tt>
</div>
<p>However you must *not* make the postfix version return the 'this' object by
reference; you have been warned.
<p>Here's how you use these operators:
<p><div class=CodeBlock>
<tt>
&nbsp;Number&nbsp;x&nbsp;=&nbsp;</tt><em>/*&nbsp;...&nbsp;*/</em><tt>;<br>
&nbsp;++x;&nbsp;&nbsp;</tt><em>//&nbsp;calls&nbsp;<nobr><tt>Number::operator++()</tt></nobr>,&nbsp;i.e.,&nbsp;calls&nbsp;<nobr><tt>x.operator++()</tt></nobr></em><tt><br>
&nbsp;x++;&nbsp;&nbsp;</tt><em>//&nbsp;calls&nbsp;<nobr><tt>Number::operator++(int)</tt></nobr>,&nbsp;i.e.,&nbsp;calls&nbsp;<nobr><tt>x.operator++(0)</tt></nobr></em><tt>
</tt>
</div>
<p>Assuming the return types are not 'void', you can use them in larger
expressions:
<p><div class=CodeBlock>
<tt>
&nbsp;Number&nbsp;x&nbsp;=&nbsp;</tt><em>/*&nbsp;...&nbsp;*/</em><tt>;<br>
&nbsp;Number&nbsp;y&nbsp;=&nbsp;++x;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>y</tt>&nbsp;will&nbsp;be&nbsp;the&nbsp;new&nbsp;value&nbsp;of&nbsp;<tt>x</tt></em><tt><br>
&nbsp;Number&nbsp;z&nbsp;=&nbsp;x++;&nbsp;&nbsp;</tt><em>//&nbsp;<tt>z</tt>&nbsp;will&nbsp;be&nbsp;the&nbsp;old&nbsp;value&nbsp;of&nbsp;<tt>x</tt></em><tt>
</tt>
</div>
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="faq-13.12"></a>
<div class=FaqTitle><h3>[13.12] Which is more efficient: <nobr><tt>i++</tt></nobr> or <nobr><tt>++i</tt></nobr>?</h3></div>
<p><nobr><tt>++i</tt></nobr> is sometimes faster than, and is never slower than, <nobr><tt>i++</tt></nobr>.
<p>For intrinsic types like <tt>int</tt>, it doesn't matter: <nobr><tt>++i</tt></nobr> and
<nobr><tt>i++</tt></nobr> are the same speed.  For class types like iterators or the
previous FAQ's <tt>Number</tt> class, <nobr><tt>++i</tt></nobr> very well might be faster
than <nobr><tt>i++</tt></nobr> since the latter might make a copy of the <tt>this</tt>
object.
<p>The overhead of <nobr><tt>i++</tt></nobr>, if it is there at all, won't probably make any
practical difference unless your app is CPU bound.  For example, if your app
spends most of its time waiting for someone to click a mouse, doing disk I/O,
network I/O, or database queries, then it won't hurt your performance to waste
a few CPU cycles.  <em>However</em> it's just as easy to type <nobr><tt>++i</tt></nobr> as
<nobr><tt>i++</tt></nobr>, so why not use the former unless you actually need the old value
of <tt>i</tt>.
<p>So if you're writing <nobr><tt>i++</tt></nobr> as a statement rather than as part of a
larger expression, why not just write <nobr><tt>++i</tt></nobr> instead?  You never lose
anything, and you sometimes gain something.  Old line C programmers are used
to writing <nobr><tt>i++</tt></nobr> instead of <nobr><tt>++i</tt></nobr>.  E.g., they'll say, <nobr><tt>for (i
= 0;</tt></nobr> <nobr><tt>i &lt; 10;</tt></nobr> <nobr><tt>i++) </tt>...<tt></tt></nobr>.  Since this uses <nobr><tt>i++</tt></nobr> as a
statement, not as a part of a larger expression, then you might want to use
<nobr><tt>++i</tt></nobr> instead.  For symmetry, I personally advocate that style even when
it doesn't improve speed, e.g., for intrinsic types and for class types with
postfix operators that return <tt>void</tt>.
<p>Obviously when <nobr><tt>i++</tt></nobr> appears as a part of a larger expression, that's
different: it's being used because it's the only logically correct solution,
not because it's an old habit you picked up while programming in C.
<p><small>[&nbsp;<a href="#top" title="Top of section [13] Operator overloading">Top</a> |&nbsp;<a href="#bottom" title="Bottom of section [13] Operator overloading">Bottom</a> |&nbsp;<a href="assignment-operators.html" title="[12] Assignment operators">Previous&nbsp;section</a> |&nbsp;<a href="friends.html" title="[14] Friends">Next&nbsp;section</a> |&nbsp;<a href="index.html#search-the-faq" title="Look up FAQs several ways">Search&nbsp;the&nbsp;FAQ</a> ]</small>
<hr>
<p><a name="bottom"></a>
<a href="mailto:cline@parashift.com" title="cline@parashift.com"><img src="mbox.gif" height=26 width=89 alt="E-Mail">&nbsp;E-mail the author</a><br>
[&nbsp;<a href="index.html" title="C++ FAQ Lite"><em>C++ FAQ Lite</em></a>
|&nbsp;<a href="index.html#table-of-contents" title="Table of contents">Table&nbsp;of&nbsp;contents</a>
|&nbsp;<a href="subject-index.html" title="Subject index; 3706 links to 2361 topics">Subject&nbsp;index</a>
|&nbsp;<a href="copy-permissions.html#faq-1.1" title="[1.1] Author">About&nbsp;the&nbsp;author</a>
|&nbsp;<a href="copy-permissions.html#faq-1.2" title="[1.2] Copyright Notice">&copy;</a>
|&nbsp;<a href="on-line-availability.html#faq-2.2" title="[2.2] How can I get a copy of all the HTML files of C++ FAQ Lite so I can read them Off-Line?">Download&nbsp;your&nbsp;own&nbsp;copy</a>&nbsp;]<br>
<small>Revised May 2, 2003</small>
</body>
</html>
